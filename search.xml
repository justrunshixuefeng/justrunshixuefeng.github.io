<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>*args和**kwargs</title>
      <link href="/2018/08/08/args%E5%92%8C-kwargs/"/>
      <url>/2018/08/08/args%E5%92%8C-kwargs/</url>
      
        <content type="html"><![CDATA[<h4 id="args-kwargs-不定长参数"><a href="#args-kwargs-不定长参数" class="headerlink" title="args  *kwargs  不定长参数"></a><em>args  *</em>kwargs  不定长参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jia</span><span class="params">(*args)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(jia(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))         <span class="comment">#6</span></span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>python函数允许同时全部或部分使用使用固定参数，默认参数，单值（一颗星）可变参数，键值对（两颗星）可变参数，使用时必须安装前述顺序书写。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(name, age=<span class="number">18</span>, *args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'姓名:%s,年龄:%d'</span> % (name, age))</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">info(<span class="string">'xuefeng'</span>, <span class="number">23</span>, <span class="number">180</span>, <span class="number">80</span>, like=<span class="string">'python'</span>, body=<span class="string">'fat'</span>)</span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/args和-kwargs/1.png" alt="img"></p><blockquote><p>此外一颗星（单值可变参数）和两颗星（键值对可变参数）还可用于列表，元组，字典的解包。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(*a)               <span class="comment"># 1 2 3</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(*b)               <span class="comment"># 1 2 3</span></span><br><span class="line">c = &#123;<span class="string">'name'</span>: <span class="string">'小明'</span>, <span class="string">'age'</span>: <span class="number">23</span>&#125;</span><br><span class="line">print(*c)               <span class="comment"># name age</span></span><br><span class="line">print(<span class="string">'name:&#123;name&#125;,age:&#123;age&#125;'</span>.format(**c))  <span class="comment"># name:小明,age:23</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>find</title>
      <link href="/2018/08/08/find/"/>
      <url>/2018/08/08/find/</url>
      
        <content type="html"><![CDATA[<h3 id="find命令格式："><a href="#find命令格式：" class="headerlink" title="find命令格式："></a>find命令格式：</h3><p>find   path  -option  【 -print 】  【 -exec   -ok   |xargs  |grep  】 【  command  {} ;  】</p><a id="more"></a><hr><p>find命令的参数：</p><ol><li><p>path：要查找的目录路径。 </p><blockquote><p>  ~ 表示$HOME目录<br>  . 表示当前目录<br>  / 表示根目录 </p></blockquote></li><li><p>print：表示将结果输出到标准输出。</p></li><li><p>exec：对匹配的文件执行该参数所给出的shell命令。 </p><pre><code>形式为command {} \;，注意{}与\;之间有空格 </code></pre></li><li><p>ok：与exec作用相同，</p><pre><code>区别在于，在执行命令之前，都会给出提示，让用户确认是否执行 </code></pre></li><li><p>|xargs  与exec作用相同 ，起承接作用</p><p>区别在于 |xargs 主要用于承接删除操作 ，而 -exec 都可用 如复制、移动、重命名等</p></li><li><p>options ：表示查找方式</p><blockquote><p>options常用的有下选项：</p><p>-name   filename               #查找名为filename的文件<br>-perm                                #按执行权限来查找<br>-user    username             #按文件属主来查找<br>-group groupname            #按组来查找<br>-mtime   -n +n                   #按文件更改时间来查找文件，-n指n天以内，+n指n天以前<br>-atime    -n +n                   #按文件访问时间来查找文件，-n指n天以内，+n指n天以前<br>-ctime    -n +n                  #按文件创建时间来查找文件，-n指n天以内，+n指n天以前<br>-nogroup                          #查无有效属组的文件，即文件的属组在/etc/groups中不存在<br>-nouser                            #查无有效属主的文件，即文件的属主在/etc/passwd中不存<br>-type    b/d/c/p/l/f             #查是块设备、目录、字符设备、管道、符号链接、普通文件<br>-size      n[c]                    #查长度为n块[或n字节]的文件<br>-mount                            #查文件时不跨越文件系统mount点<br>-follow                            #如果遇到符号链接文件，就跟踪链接所指的文件<br>-prune                            #忽略某个目录</p></blockquote></li></ol><hr><p>下面通过一些简单的例子来介绍下find的常规用法： </p><h4 id="1、按名字查找"><a href="#1、按名字查找" class="headerlink" title="1、按名字查找"></a>1、按名字查找</h4><pre><code>在当前目录及子目录中，查找大写字母开头的txt文件  $ find . -name &apos;[A-Z]*.txt&apos; -print 　　在/etc及其子目录中，查找host开头的文件 $ find /etc -name &apos;host*&apos; -print 　　在$HOME目录及其子目录中，查找所有文件 　　$ find ~ -name &apos;*&apos; -print 在当前目录及子目录中，查找不是out开头的txt文件 　　$ find . -name &quot;out*&quot; -prune -o -name &quot;*.txt&quot; -print </code></pre><h4 id="2、按目录查找"><a href="#2、按目录查找" class="headerlink" title="2、按目录查找 　　"></a>2、按目录查找 　　</h4><pre><code>在当前目录除aa之外的子目录内搜索 txt文件 　　$ find . -path &quot;./aa&quot; -prune -o -name &quot;*.txt&quot; -print 　　在当前目录及除aa和bb之外的子目录中查找txt文件 　　$ find . −path′./dir0′−o−path′./dir1′−path′./dir0′−o−path′./dir1′ -a -prune -o -name &apos;*.txt&apos; -print</code></pre><p>注意：在1、2处都需要加空格，否则会出现如图所示的报错</p><pre><code>      在3处加不加 -a都可以 在当前目录，不再子目录中，查找txt文件  $ find . ! -name &quot;.&quot; -type d -prune -o -type f -name &quot;*.txt&quot; -print 或者   find . -name *.txt -type f -print</code></pre><p>友情链接：Linux中find命令-path -prune用法详解</p><h4 id="3、按权限查找"><a href="#3、按权限查找" class="headerlink" title="3、按权限查找 　　"></a>3、按权限查找 　　</h4><p>​      </p><pre><code>在当前目录及子目录中，查找属主具有读写执行，其他具有读执行权限的文件 　　$ find . -perm 755 -print 查找用户有写权限或者组用户有写权限的文件或目录find ./ -perm /220find ./ -perm /u+w,g+wfind ./ -perm /u=w,g=w</code></pre><h4 id="4、按类型查找-（b-d-c-p-l-f-）"><a href="#4、按类型查找-（b-d-c-p-l-f-）" class="headerlink" title="4、按类型查找 　（b/d/c/p/l/f ）　"></a>4、按类型查找 　（b/d/c/p/l/f ）　</h4><pre><code>在当前目录及子目录下，查找符号链接文件 　　$ find . -type l -print </code></pre><h4 id="5、按属主及属组"><a href="#5、按属主及属组" class="headerlink" title="5、按属主及属组 　　"></a>5、按属主及属组 　　</h4><pre><code>查找属主是www的文件 　　$ find / -user www -type f -print 　　查找属主被删除的文件 $ find / -nouser -type f -print 　　查找属组 mysql 的文件 $ find / -group mysql -type f -print 　　查找用户组被删掉的文件 $ find / -nogroup -type f -print </code></pre><h4 id="6、按时间查找"><a href="#6、按时间查找" class="headerlink" title="6、按时间查找 　　"></a>6、按时间查找 　　</h4><pre><code>查找2天内被更改过的文件  $ find . -mtime -2 -type f -print 　　查找2天前被更改过的文件 $ find . -mtime +2 -type f -print 　　查找一天内被访问的文件 $ find . -atime -1 -type f -print 　　查找一天前被访问的文件 $ find . -atime +1 -type f -print 　　查找一天内状态被改变的文件 $ find . -ctime -1 -type f -print 　　查找一天前状态被改变的文件 $ find . -ctime +1 -type f -print 　　查找10分钟以前状态被改变的文件 $ find . -cmin +10 -type f -print </code></pre><h4 id="7、按文件新旧"><a href="#7、按文件新旧" class="headerlink" title="7、按文件新旧 　　"></a>7、按文件新旧 　　</h4><p>​      </p><pre><code>查找比 aa.txt 新的文件 $ find . -newer &quot;aa.txt&quot; -type f -print 　　查找比 aa.txt 旧的文件 $ find . ! -newer &quot;aa.txt&quot; -type f -print 　　查找比aa.txt新，比bb.txt旧的文件 $ find . -newer &apos;aa.txt&apos; ! -newer &apos;bb.txt&apos; -type f -print </code></pre><h4 id="8、按大小查找"><a href="#8、按大小查找" class="headerlink" title="8、按大小查找 　　"></a>8、按大小查找 　　</h4><pre><code>查找超过1M的文件 $ find / -size +1M -type f -print 　　查找等于6字节的文件 $ find . -size 6c -print 　　查找小于32k的文件 $ find . -size -32k -print </code></pre><h4 id="9、执行命令"><a href="#9、执行命令" class="headerlink" title="9、执行命令 　　"></a>9、执行命令 　　</h4><p>​      </p><pre><code>  1）查找 del.txt 并删除，删除前提示确认   $ find . -name &apos;del.txt&apos; -ok rm {} \; 　　 2） 查找 aa.txt 并备份为aa.txt.bak   $ find . -name &apos;aa.txt&apos; -exec cp {} {}.bak \; 3）查当前目录下的所有普通文件# find . -type f -exec ls -l {} \; </code></pre><p>   -rw-r–r–    1 root      root         34928 2003-02-25   ./conf/httpd.conf<br>   -rw-r–r–    1 root      root         12959 2003-02-25   ./conf/magic<br>   -rw-r–r–    1 root      root          180 2003-02-25   ./conf.d/README </p><p>   查当前目录下的所有普通文件，并在 - exec 选项中使用 ls -l 命令将它们列出</p><p>   4）在 /logs 目录中查找更改时间在5日以前的文件并删除它们<br>   $ find logs -type f -mtime +5 -exec   -ok   rm {} ;</p><p>   5）查询当天修改过的文件</p><p>   $ find  ./  -mtime  -1  -type f  -exec  ls -l  {} ; </p><p>   6）查询文件并询问是否要显示</p><pre><code># find   ./   -mtime   -1   -type f   -ok   ls -l   {} \;  &lt; ls … ./classDB.inc.php &gt; ? y-rw-r–r–    1 cnscn    cnscn       13709   1月 12 12:22 ./classDB.inc.php# find   ./   -mtime   -1   -type f   -ok   ls -l   {} \;  &lt; ls … ./classDB.inc.php &gt; ? n</code></pre><p>关于 有没有 -print 的区别</p><h5 id="加-print"><a href="#加-print" class="headerlink" title="加  -print"></a>加  -print</h5><p>查找目录并列出目录下的文件(为找到的每一个目录单独执行ls命令，没有选项-print时文件列表前一行不会显示目录名称)<br>find . -type d -print -exec ls {} ;</p><p><img src="/2018/08/08/find/1.png" alt="img"></p><h5 id="不加-print"><a href="#不加-print" class="headerlink" title="不加 -print"></a>不加 -print</h5><p><img src="/2018/08/08/find/2.png" alt="img"></p><hr><p>原文链接：<a href="https://blog.csdn.net/l_liangkk/article/details/81294260" target="_blank" rel="noopener">https://blog.csdn.net/l_liangkk/article/details/81294260</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep</title>
      <link href="/2018/08/08/grep/"/>
      <url>/2018/08/08/grep/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：grep这个命令都不陌生，最常用的就是和管道符结合，例如：ps-ef-grep-docker。"><a href="#前言：grep这个命令都不陌生，最常用的就是和管道符结合，例如：ps-ef-grep-docker。" class="headerlink" title="前言：grep这个命令都不陌生，最常用的就是和管道符结合，例如：ps -ef | grep docker。"></a>前言：grep这个命令都不陌生，最常用的就是和管道符结合，例如：ps -ef | grep docker。</h2><p>Grep称为全局正则表达式检索工具，在企业中被广泛的采用。</p><a id="more"></a><h2 id="grep的语法格式："><a href="#grep的语法格式：" class="headerlink" title="grep的语法格式："></a>grep的语法格式：</h2><p>grep  -option（参数） ‘word’（关键词） file（文本文件）；</p><h2 id="grep参数："><a href="#grep参数：" class="headerlink" title="grep参数："></a>grep参数：</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-a 不要忽略二进制数据。</span></span><br><span class="line"><span class="deletion">-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</span></span><br><span class="line"><span class="deletion">-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。</span></span><br><span class="line"><span class="deletion">-c 计算符合范本样式的列数。</span></span><br><span class="line"><span class="deletion">-C&lt;显示列数&gt;或-&lt;显示列数&gt;  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span></span><br><span class="line"><span class="deletion">-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。</span></span><br><span class="line"><span class="deletion">-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。</span></span><br><span class="line"><span class="deletion">-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</span></span><br><span class="line"><span class="deletion">-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。</span></span><br><span class="line"><span class="deletion">-F 将范本样式视为固定字符串的列表。</span></span><br><span class="line"><span class="deletion">-G 将范本样式视为普通的表示法来使用。</span></span><br><span class="line"><span class="deletion">-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span></span><br><span class="line"><span class="deletion">-H 在显示符合范本样式的那一列之前，标示该列的文件名称。</span></span><br><span class="line"><span class="deletion">-i 忽略字符大小写的差别。</span></span><br><span class="line"><span class="deletion">-l 列出文件内容符合指定的范本样式的文件名称。</span></span><br><span class="line"><span class="deletion">-L 列出文件内容不符合指定的范本样式的文件名称。</span></span><br><span class="line"><span class="deletion">-n 在显示符合范本样式的那一列之前，标示出该列的编号。</span></span><br><span class="line"><span class="deletion">-q 不显示任何信息。</span></span><br><span class="line"><span class="deletion">-R/-r 此参数的效果和指定“-d recurse”参数相同。</span></span><br><span class="line"><span class="deletion">-s 不显示错误信息。</span></span><br><span class="line"><span class="deletion">-v 反转查找。</span></span><br><span class="line"><span class="deletion">-w 只显示全字符合的列。</span></span><br><span class="line"><span class="deletion">-x 只显示全列符合的列。</span></span><br><span class="line"><span class="deletion">-y 此参数效果跟“-i”相同。</span></span><br><span class="line"><span class="deletion">-o 只输出文件中匹配到的部分。</span></span><br></pre></td></tr></table></figure><h2 id="grep常见用法："><a href="#grep常见用法：" class="headerlink" title="grep常见用法："></a>grep常见用法：</h2><h3 id="1-查找-etc-passwd文件中是否存在quail用户信息"><a href="#1-查找-etc-passwd文件中是否存在quail用户信息" class="headerlink" title="1.查找/etc/passwd文件中是否存在quail用户信息"></a>1.查找/etc/passwd文件中是否存在quail用户信息</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@www</span> sed]<span class="comment"># grep "quail" /etc/passwd</span></span><br><span class="line"><span class="symbol">quail:</span><span class="symbol">x:</span><span class="number">1000</span><span class="symbol">:</span><span class="number">1000</span><span class="symbol">:quail</span><span class="symbol">:/home/quail</span><span class="symbol">:/bin/bash</span></span><br><span class="line">[root<span class="variable">@www</span> sed]<span class="comment"># grep -w "quail" /etc/passwd</span></span><br><span class="line"><span class="symbol">quail:</span><span class="symbol">x:</span><span class="number">1000</span><span class="symbol">:</span><span class="number">1000</span><span class="symbol">:quail</span><span class="symbol">:/home/quail</span><span class="symbol">:/bin/bash</span></span><br><span class="line">[root<span class="variable">@www</span> sed]<span class="comment"># grep -i quail /etc/passwd</span></span><br><span class="line"><span class="symbol">quail:</span><span class="symbol">x:</span><span class="number">1000</span><span class="symbol">:</span><span class="number">1000</span><span class="symbol">:quail</span><span class="symbol">:/home/quail</span><span class="symbol">:/bin/bash</span></span><br></pre></td></tr></table></figure><h3 id="2-ifconfig看到网卡信息，只查看IP地址所在行信息"><a href="#2-ifconfig看到网卡信息，只查看IP地址所在行信息" class="headerlink" title="2.ifconfig看到网卡信息，只查看IP地址所在行信息"></a>2.ifconfig看到网卡信息，只查看IP地址所在行信息</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# ifconfig |grep -w inet</span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.249</span><span class="number">.132</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.249</span><span class="number">.255</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">[root@www sed]# ifconfig |grep netmask</span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.249</span><span class="number">.132</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.249</span><span class="number">.255</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">[root@www sed]# ifconfig |grep -w <span class="number">255</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.249</span><span class="number">.132</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.249</span><span class="number">.255</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">[root@www sed]# ifconfig |grep -E <span class="string">"192|127"</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.249</span><span class="number">.132</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.249</span><span class="number">.255</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">[root@www sed]# ifconfig |grep -E <span class="string">"([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;"</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.249</span><span class="number">.132</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.249</span><span class="number">.255</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h4 id="实验需要，新建list-txt并写入如下内容："><a href="#实验需要，新建list-txt并写入如下内容：" class="headerlink" title="实验需要，新建list.txt并写入如下内容："></a>实验需要，新建list.txt并写入如下内容：</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# cat <span class="type">list</span>.txt </span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.4</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.5</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span> www <span class="number">123456</span></span><br><span class="line"><span class="number">1111.222</span><span class="number">.111</span><span class="number">.111</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">111.22</span><span class="number">.11</span><span class="number">.1111</span> root <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="3-统计root-字符总行数"><a href="#3-统计root-字符总行数" class="headerlink" title="3.统计root 字符总行数"></a>3.统计root 字符总行数</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@www</span> sed]<span class="meta"># grep -c root list.txt </span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="4-不区分大小写查找RoOt所有行"><a href="#4-不区分大小写查找RoOt所有行" class="headerlink" title="4.不区分大小写查找RoOt所有行"></a>4.不区分大小写查找RoOt所有行</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep -i RoOt <span class="type">list</span>.txt </span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.4</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.5</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">1111.222</span><span class="number">.111</span><span class="number">.111</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">111.22</span><span class="number">.11</span><span class="number">.1111</span> root <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="5-打印www行以及行号"><a href="#5-打印www行以及行号" class="headerlink" title="5.打印www行以及行号"></a>5.打印www行以及行号</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@www sed]</span># <span class="selector-tag">grep</span> <span class="selector-tag">-n</span> <span class="selector-tag">www</span> <span class="selector-tag">list</span><span class="selector-class">.txt</span> </span><br><span class="line">6<span class="selector-pseudo">:172.0.0.1</span> <span class="selector-tag">www</span> 123456</span><br></pre></td></tr></table></figure><h3 id="6-不打印root行"><a href="#6-不打印root行" class="headerlink" title="6.不打印root行"></a>6.不打印root行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@www sed]</span># <span class="selector-tag">grep</span> <span class="selector-tag">-v</span> <span class="selector-tag">root</span> <span class="selector-tag">list</span><span class="selector-class">.txt</span> </span><br><span class="line">172<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">www</span> 123456</span><br></pre></td></tr></table></figure><h3 id="7-以168-开头的接3-5的行"><a href="#7-以168-开头的接3-5的行" class="headerlink" title="7.以168.开头的接3 5的行"></a>7.以168.开头的接3 5的行</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep <span class="string">"168.[35]"</span> <span class="type">list</span>.txt </span><br><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.5</span><span class="number">.11</span> root <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="8-显示输出行首不是192的行"><a href="#8-显示输出行首不是192的行" class="headerlink" title="8.显示输出行首不是192的行"></a>8.显示输出行首不是192的行</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep -E -v  <span class="string">"^192"</span> <span class="type">list</span>.txt </span><br><span class="line"><span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span> www <span class="number">123456</span></span><br><span class="line"><span class="number">1111.222</span><span class="number">.111</span><span class="number">.111</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">111.22</span><span class="number">.11</span><span class="number">.1111</span> root <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="9-匹配R或r开头的行-提前echo-“root-123-nRoot-123”-gt-list-txt"><a href="#9-匹配R或r开头的行-提前echo-“root-123-nRoot-123”-gt-list-txt" class="headerlink" title="9.匹配R或r开头的行,提前echo “root 123\nRoot 123” &gt; list.txt"></a>9.匹配R或r开头的行,提前echo “root 123\nRoot 123” &gt; list.txt</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep -E <span class="string">"^[Rr]oot"</span> <span class="type">list</span>.txt </span><br><span class="line">root <span class="number">1234</span> <span class="number">2134</span> <span class="number">123</span></span><br><span class="line">Root <span class="number">123</span> <span class="number">123</span> <span class="number">123</span> <span class="number">786</span></span><br></pre></td></tr></table></figure><h3 id="10-匹配r，两个任意字符，紧接t的行"><a href="#10-匹配r，两个任意字符，紧接t的行" class="headerlink" title="10.匹配r，两个任意字符，紧接t的行"></a>10.匹配r，两个任意字符，紧接t的行</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep <span class="string">"r..t"</span> <span class="type">list</span>.txt </span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.4</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.5</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">1111.222</span><span class="number">.111</span><span class="number">.111</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">111.22</span><span class="number">.11</span><span class="number">.1111</span> root <span class="number">123456</span></span><br><span class="line">root <span class="number">1234</span> <span class="number">2134</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="11-匹配字母紧跟w-的行"><a href="#11-匹配字母紧跟w-的行" class="headerlink" title="11.匹配字母紧跟w 的行"></a>11.匹配字母紧跟w 的行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@www sed]</span># <span class="selector-tag">grep</span> <span class="selector-tag">-E</span> "<span class="selector-attr">[a-Z]</span><span class="selector-tag">w</span> " <span class="selector-tag">list</span><span class="selector-class">.txt</span> </span><br><span class="line">172<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">www</span> 123456</span><br></pre></td></tr></table></figure><h3 id="12-打印字符w字符连续出现2次以上的行"><a href="#12-打印字符w字符连续出现2次以上的行" class="headerlink" title="12.打印字符w字符连续出现2次以上的行"></a>12.打印字符w字符连续出现2次以上的行</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep <span class="string">"w\&#123;2,\&#125;"</span> <span class="type">list</span>.txt </span><br><span class="line"><span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span> www <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="13-打印字符o连续出现3次和5次的行"><a href="#13-打印字符o连续出现3次和5次的行" class="headerlink" title="13.打印字符o连续出现3次和5次的行"></a>13.打印字符o连续出现3次和5次的行</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@www</span> sed]<span class="meta"># grep <span class="string">"o\&#123;3,5\&#125;"</span> list.txt </span></span><br><span class="line">rooot</span><br><span class="line">rooooot</span><br></pre></td></tr></table></figure><h3 id="14-打印-usr-local-nginx-conf-nginx-conf-default空行的所在的行号"><a href="#14-打印-usr-local-nginx-conf-nginx-conf-default空行的所在的行号" class="headerlink" title="14.打印/usr/local/nginx/conf/nginx.conf.default空行的所在的行号"></a>14.打印/usr/local/nginx/conf/nginx.conf.default空行的所在的行号</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]<span class="comment"># grep -n "^$" /usr/local/nginx/conf/nginx.conf.default </span></span><br><span class="line"><span class="section">1:</span></span><br><span class="line"><span class="section">4:</span></span><br><span class="line"><span class="section">8:</span></span><br><span class="line"><span class="section">10:</span></span><br><span class="line"><span class="section">11:</span></span><br><span class="line"><span class="section">15:</span></span><br><span class="line"><span class="section">16:</span></span><br><span class="line"><span class="section">20:</span></span><br><span class="line"><span class="section">24:</span></span><br><span class="line"><span class="section">26:</span></span><br><span class="line"><span class="section">29:</span></span><br><span class="line"><span class="section">32:</span></span><br><span class="line"><span class="section">34:</span></span><br><span class="line"><span class="section">38:</span></span><br><span class="line"><span class="section">40:</span></span><br><span class="line"><span class="section">42:</span></span><br><span class="line"><span class="section">47:</span></span><br><span class="line"><span class="section">49:</span></span><br><span class="line"><span class="section">56:</span></span><br><span class="line"><span class="section">62:</span></span><br><span class="line"><span class="section">72:</span></span><br><span class="line"><span class="section">80:</span></span><br><span class="line"><span class="section">81:</span></span><br><span class="line"><span class="section">88:</span></span><br><span class="line"><span class="section">94:</span></span><br><span class="line"><span class="section">95:</span></span><br><span class="line"><span class="section">101:</span></span><br><span class="line"><span class="section">104:</span></span><br><span class="line"><span class="section">107:</span></span><br><span class="line"><span class="section">110:</span></span><br><span class="line"><span class="section">116:</span></span><br></pre></td></tr></table></figure><h3 id="15-过滤-usr-local-nginx-conf-nginx-conf-default文件中的-和空行以及行号"><a href="#15-过滤-usr-local-nginx-conf-nginx-conf-default文件中的-和空行以及行号" class="headerlink" title="15.过滤/usr/local/nginx/conf/nginx.conf.default文件中的#和空行以及行号"></a>15.过滤/usr/local/nginx/conf/nginx.conf.default文件中的#和空行以及行号</h3><p>[root@www sed]# grep -E -v -n “#|^$” /usr/local/nginx/conf/nginx.conf.default<br>3:worker_processes 1;<br>12:events {<br>13: worker_connections 1024;<br>14:}<br>17:http {<br>18: include mime.types;<br>19: default_type application/octet-stream;<br>27: sendfile on;<br>31: keepalive_timeout 65;<br>35: server {<br>36: listen 80;<br>37: server_name localhost;<br>43: location / {<br>44: root html;<br>45: index index.html index.htm;<br>46: }<br>52: error_page 500 502 503 504 /50x.html;<br>53: location = /50x.html {<br>54: root html;<br>55: }<br>79: }<br>117:}</p><h3 id="16-当前目录下文件内匹配包含quail或test或anchun的文件"><a href="#16-当前目录下文件内匹配包含quail或test或anchun的文件" class="headerlink" title="16.当前目录下文件内匹配包含quail或test或anchun的文件"></a>16.当前目录下文件内匹配包含quail或test或anchun的文件</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">`seq 1 3`</span>;<span class="keyword">do</span> echo quail$i &gt; test$i.txt ;done</span><br><span class="line">[root@www sed]# <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">`seq 1 3`</span>;<span class="keyword">do</span> echo test$i &gt; yoyoyo$i.txt ;done</span><br><span class="line">[root@www sed]# <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">`seq 1 3`</span>;<span class="keyword">do</span> echo anchun$i &gt; lalal$i.txt ;done</span><br><span class="line">[root@www sed]# <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">`seq 1 3`</span>;<span class="keyword">do</span> echo <span class="keyword">error</span>$i &gt; yingyingying$i.txt ;done ######实验环境######</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# <span class="keyword">grep</span> -E -ra <span class="string">"quail|test|anchun"</span> *</span><br><span class="line">lalal1.tx<span class="variable">t:anchun1</span></span><br><span class="line">lalal2.tx<span class="variable">t:anchun2</span></span><br><span class="line">lalal3.tx<span class="variable">t:anchun3</span></span><br><span class="line">test1.tx<span class="variable">t:quail1</span></span><br><span class="line">test2.tx<span class="variable">t:quail2</span></span><br><span class="line">test3.tx<span class="variable">t:quail3</span></span><br><span class="line">yoyoyo1.tx<span class="variable">t:test1</span></span><br><span class="line">yoyoyo2.tx<span class="variable">t:test2</span></span><br><span class="line">yoyoyo3.tx<span class="variable">t:test3</span></span><br></pre></td></tr></table></figure><h3 id="17-匹配IPV4地址"><a href="#17-匹配IPV4地址" class="headerlink" title="17.匹配IPV4地址"></a>17.匹配IPV4地址</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep -E -w --color <span class="string">"([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;"</span> <span class="type">list</span>.txt </span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.4</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.5</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span> www <span class="number">123456</span></span><br></pre></td></tr></table></figure><hr><p>原文链接： <a href="https://www.cnblogs.com/quail2333/p/11179106.html" target="_blank" rel="noopener">https://www.cnblogs.com/quail2333/p/11179106.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引类型及创建索引</title>
      <link href="/2018/08/08/mysql%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/08/08/mysql%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><h6 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h6><p>​        MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。索引如图所示：</p><a id="more"></a><p><img src="/2018/08/08/mysql索引类型及创建索引/B%E6%A0%91%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="B树"></p><p>​        索引类似一本书的目录，可以提高数据检索的效率，降低数据库的IO成本。MySQL在300万条记录左右性能开始逐渐下降，虽然官方文档说500~800w记录，所以大数据量建立索引是非常有必要的。MySQL提供了Explain，用于显示SQL执行的详细信息，可以进行索引的优化。 </p><p>MySQL目前主要有以下几种索引类型：</p><p>1.<strong>普通索引</strong></p><p>2.<strong>唯一索引</strong></p><p>3.<strong>主键索引</strong></p><p>4.<strong>联合索引</strong></p><p>5.<strong>联合唯一索引</strong></p><p>6.<strong>全文索引</strong></p><h4 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name[col_name]</span><br><span class="line">[unique|fulltext] [index|key] [index_name] (col_name[length])[asc|desc]</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">CREATE TABLE [unique|fulltext] [index|key] [index_name] on table_name[col_name[length]] [asc|desc]</span><br></pre></td></tr></table></figure><h6 id="1-unique-fulltext为可选参数，分别表示唯一索引、全文索引"><a href="#1-unique-fulltext为可选参数，分别表示唯一索引、全文索引" class="headerlink" title="1.unique|fulltext为可选参数，分别表示唯一索引、全文索引"></a>1.unique|fulltext为可选参数，分别表示唯一索引、全文索引</h6><h6 id="2-index和key为同义词，两者作用相同，用来指定创建索引"><a href="#2-index和key为同义词，两者作用相同，用来指定创建索引" class="headerlink" title="2.index和key为同义词，两者作用相同，用来指定创建索引"></a>2.index和key为同义词，两者作用相同，用来指定创建索引</h6><h6 id="3-col-name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择"><a href="#3-col-name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择" class="headerlink" title="3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择"></a>3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择</h6><h6 id="4-index-name指定索引的名称，为可选参数，如果不指定，默认col-name为索引值"><a href="#4-index-name指定索引的名称，为可选参数，如果不指定，默认col-name为索引值" class="headerlink" title="4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值"></a>4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值</h6><h6 id="5-length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度"><a href="#5-length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度" class="headerlink" title="5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度"></a>5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度</h6><h6 id="6-asc或desc指定升序或降序的索引值存储"><a href="#6-asc或desc指定升序或降序的索引值存储" class="headerlink" title="6.asc或desc指定升序或降序的索引值存储"></a>6.asc或desc指定升序或降序的索引值存储</h6><blockquote><h4 id="注意：create-语法不能创建主键索引-只有alter语法可以！"><a href="#注意：create-语法不能创建主键索引-只有alter语法可以！" class="headerlink" title="注意：create 语法不能创建主键索引,只有alter语法可以！"></a>注意：create 语法不能创建主键索引,只有alter语法可以！</h4></blockquote><h4 id="三、索引类型"><a href="#三、索引类型" class="headerlink" title="三、索引类型"></a>三、索引类型</h4><h6 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1.普通索引"></a>1.普通索引</h6><p>是最基本的索引，它没有任何限制。它有以下几种创建方式：<br>（1）直接创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table(column(length))</span><br></pre></td></tr></table></figure><p>（2）修改表结构的方式添加索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name ON (column(length))</span><br></pre></td></tr></table></figure><p>（3）创建表的时候同时创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    INDEX index_name (title(length))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>（4）删除索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure><h6 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2.唯一索引"></a>2.唯一索引</h6><p>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：<br>（1）创建唯一索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON table(column(length))</span><br><span class="line"></span><br><span class="line"># 还有一种情况就是,我们需要为以前的表 创建这个索引,有可能以前的数据中存在重复的记录 那怎么办呢? </span><br><span class="line">alter ignore table tablename add unique index(aa); </span><br><span class="line">#它会删除重复的记录（会保留一条），然后建立唯一索引，高效而且人性化。</span><br></pre></td></tr></table></figure><p>（2）修改表结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))</span><br></pre></td></tr></table></figure><p>（3）创建表的时候直接指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    UNIQUE indexName (title(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h6 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h6><p>是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) NOT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>设置字段为主键索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` );</span><br></pre></td></tr></table></figure><h6 id="4-联合索引（复合索引）"><a href="#4-联合索引（复合索引）" class="headerlink" title="4.联合索引（复合索引）"></a>4.联合索引（复合索引）</h6><blockquote><p>​        指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p><p>​        两个或更多个列上的索引被称作复合索引。</p><p>​        利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名字不知道姓，电话簿将没有任何用处。</p><p>​        所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table` ADD INDEX name_city_age (name,city,age);</span><br></pre></td></tr></table></figure><h6 id="5-联合唯一索引（复合唯一索引）"><a href="#5-联合唯一索引（复合唯一索引）" class="headerlink" title="5.联合唯一索引（复合唯一索引）"></a>5.联合唯一索引（复合唯一索引）</h6><blockquote><p> 多列惟一性索引，保证多个值的组合不重复。 </p></blockquote><p>(1) 创建联合唯一索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line"># create unique index 索引名字 on 表名(字段1，字段2) </span><br><span class="line">create unique index uni_index on user(phone,address);</span><br><span class="line"></span><br><span class="line"># 还有一种情况就是,我们需要为以前的表 创建这个索引,有可能以前的数据中存在重复的记录 那怎么办呢? </span><br><span class="line">alter ignore table tablename add unique index(aa,bb); </span><br><span class="line">#它会删除重复的记录（会保留一条），然后建立唯一索引，高效而且人性化。</span><br></pre></td></tr></table></figure><p>(2) 删除索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index 索引名字 on 表名;</span><br></pre></td></tr></table></figure><h6 id="6-全文索引"><a href="#6-全文索引" class="headerlink" title="6.全文索引"></a>6.全文索引</h6><blockquote><p>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。</p><p> 全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。 </p><p> 在MySQL 5.6版本以前,只有MyISAM存储引擎支持全文引擎.在5.6版本中,InnoDB加入了对全文索引的支持,但是不支持中文全文索引.在5.7.6版本,MySQL内置了ngram全文解析器,用来支持亚洲语种的分词. </p></blockquote><p>（1）创建表的适合添加全文索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    FULLTEXT (content)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（2）修改表结构添加全文索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE article ADD FULLTEXT index_content(content)</span><br></pre></td></tr></table></figure><p>（3）直接创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX index_content ON article(content)</span><br></pre></td></tr></table></figure><p>（4）使用全文索引</p><p>​    跟普通索引稍有不同</p><p>   使用全文索引的格式：  MATCH (columnName) AGAINST (‘string’)</p><p>   eg:</p><p>​     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `student` WHERE MATCH(`name`) AGAINST(&apos;聪&apos;)</span><br></pre></td></tr></table></figure><p>​    当查询多列数据时：</p><p>​    建议在此多列数据上创建一个联合的全文索引，否则使用不了索引的。</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `student` WHERE MATCH(`name`,`address`) AGAINST(&apos;聪 广东&apos;)</span><br></pre></td></tr></table></figure><p>（5）使用全文索引需要注意的是：(基本单位是词)</p><ul><li><p>分词，全文索引以词为基础的，MySQL默认的分词是所有非字母和数字的特殊符号都是分词符(外国人嘛)</p></li><li><p>MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。通俗点就是说，想对一个词语使用全文索引搜索，那么这个词语的长度必须在以上两个变量的区间内。</p><p>这两个的默认值可以使用以下命令查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%ft%'</span>;</span><br></pre></td></tr></table></figure><p>1<br>可以看到这两个变量在 MyISAM 和 InnoDB 两种存储引擎下的变量名和默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// MyISAM</span><br><span class="line">ft_min_word_len = 4;</span><br><span class="line">ft_max_word_len = 84;</span><br><span class="line"></span><br><span class="line">// InnoDB</span><br><span class="line">innodb_ft_min_token_size = 3;</span><br><span class="line">innodb_ft_max_token_size = 84;</span><br></pre></td></tr></table></figure><p>可以看到最小搜索长度 MyISAM 引擎下默认是 4，InnoDB 引擎下是 3，也即，MySQL 的全文索引只会对长度大于等于 4 或者 3 的词语建立索引，而刚刚搜索的只有 aaaa 的长度大于等于 4。</p><p>看下图：</p><img src="/2018/08/08/mysql索引类型及创建索引/全文索引相关变量.png" alt="全文索引配置图片" style="zoom:80%;"></li></ul><p>​    </p><h4 id="四、缺点"><a href="#四、缺点" class="headerlink" title="四、缺点"></a>四、缺点</h4><ol><li><p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。</p></li><li><p>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快。</p></li></ol><h4 id="五、什么时候需要创建索引"><a href="#五、什么时候需要创建索引" class="headerlink" title="五、什么时候需要创建索引"></a>五、什么时候需要创建索引</h4><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找）</li><li>查询中统计或者分组的字段；</li></ol><h4 id="六、什么时候不需要创建索引"><a href="#六、什么时候不需要创建索引" class="headerlink" title="六、什么时候不需要创建索引"></a>六、什么时候不需要创建索引</h4><ol><li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件</li><li>where条件里用不到的字段，不创建索引；</li><li>表记录太少，不需要创建索引；</li><li>经常增删改的表；</li><li>数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。</li></ol><h4 id="七，注意事项-某些索引失效的情况"><a href="#七，注意事项-某些索引失效的情况" class="headerlink" title="七，注意事项(某些索引失效的情况)"></a>七，注意事项(某些索引失效的情况)</h4><blockquote><p>​        使用索引时，有以下一些技巧和注意事项：</p></blockquote><ol><li><strong>索引不会包含有null值的列</strong>。<br>只要列中包含有null值都将不会被包含在索引中，复合索引中只要有一列含有null值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为null。</li></ol><ol start="2"><li><strong>使用短索引。</strong><br>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个char(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li></ol><ol start="3"><li><strong>索引列排序</strong>。<br>查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</li></ol><ol start="4"><li><p><strong>like语句操作。</strong><br>一般情况下不推荐使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用索引</span><br><span class="line">select * from user where phone like&apos;1310001%&apos;</span><br><span class="line"></span><br><span class="line"># 将不会使用索引</span><br><span class="line">select * from user where phone like&apos;%310001%&apos;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p><strong>不要在列上进行运算</strong>。</p><blockquote><p>目前，MySQL没有支持函数索引。 这意味着如果在列上使用索引，表达式YEAR(column)也不会</p><p>利用索引。等于说是给字段进行运算会导致索引失效</p></blockquote></li></ol><p>   这将导致索引失效而进行全表扫描，例如</p><p>   SELECT * FROM table_name WHERE YEAR(column_name)&lt;2019;</p><p>   可以改成：</p><pre><code>SELECT * FROM table_name WHERE  column_name &lt; &apos;2019-01-01&apos;;</code></pre><ol start="6"><li><strong>如果条件中有or，即使其中有条件带索引也不会使用索引 ， 要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</strong>。 </li></ol><ol start="7"><li><p><strong>对于多列索引，不是使用的第一部分（最左前缀），则不会使用索引。 Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</strong></p><p>例如索引是key index (a,b,c). 可以支持*<em>a| *</em>a,b| a,b,c,  3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p></li></ol><ol start="8"><li><strong>如果 mysql 估计使用全表扫描要比使用索引快,则不使用索引。</strong> </li></ol><ol start="9"><li><strong>在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。</strong></li></ol><ol start="10"><li><strong>如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。</strong></li></ol><ol start="11"><li><p><strong>强制类型转换会全表扫描，</strong></p><p>如果phone字段是varcher类型，则下面的SQL不能命中索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select  *  fromuser where phone=13800001234;</span><br></pre></td></tr></table></figure><p>这样就可以命中索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select  *  fromuser where phone=&apos;13800001234&apos;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="八，查看sql语句执行时间和效率"><a href="#八，查看sql语句执行时间和效率" class="headerlink" title="八，查看sql语句执行时间和效率"></a>八，查看sql语句执行时间和效率</h4><h5 id="查看执行时间"><a href="#查看执行时间" class="headerlink" title="查看执行时间"></a>查看执行时间</h5><ol><li>show profiles; </li><li>show variables;查看profiling 是否是on状态； </li><li>如果是off，则 set profiling = 1； </li><li>执行自己的sql语句； </li><li>show profiles；就可以查到sql语句的执行时间；</li></ol><h5 id="查看操作了多少行"><a href="#查看操作了多少行" class="headerlink" title="查看操作了多少行"></a>查看操作了多少行</h5><p>在sql语句前面加上 explain就可以了；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain select * from event;  </span><br><span class="line">+—-+————-+——-+——+—————+——+———+——+——+——-+  </span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |  </span><br><span class="line">+—-+————-+——-+——+—————+——+———+——+——+——-+  </span><br><span class="line">| 1 | SIMPLE | event | ALL | NULL | NULL | NULL | NULL | 13 | |  </span><br><span class="line">+—-+————-+——-+——+—————+——+———+——+——+——-+  </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="各个属性的含义"><a href="#各个属性的含义" class="headerlink" title="各个属性的含义"></a>各个属性的含义</h5><p>各个属性的含义</p><p><strong>id</strong></p><ul><li>​    select查询的序列号， 这个不重要,查询序号即为sql语句执行的顺序 。</li></ul><p><strong>select_type</strong></p><ul><li>​    select查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询。</li></ul><p><strong>table</strong></p><ul><li>​    输出的行所引用的表。</li></ul><p><strong>type</strong></p><ul><li>​    联合查询所使用的类型。</li></ul><ul><li>​    type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</li></ul><ul><li><p>​    system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt;       index_subquery &gt; range &gt; index &gt; ALL</p><p>​    一般来说，得保证查询至少达到range级别，最好能达到ref。</p></li></ul><p><strong>possible_keys</strong></p><ul><li>​    指出MySQL能使用哪个索引在该表中找到行。如果是空的，没有相关的索引。这时要提高性     能，可    通过检验WHERE子句，看是否引用某些字段，或者检查字段不是适合索引。</li></ul><p><strong>key</strong></p><ul><li>​    显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。</li></ul><p><strong>key_len</strong></p><ul><li>​    显示MySQL决定使用的键长度。如果键是NULL，长度就是NULL。文档提示特别注意这个值可以得    出一个多重主键里mysql实际使用了哪一部分。</li></ul><p><strong>ref</strong></p><ul><li>​    显示哪个字段或常数与key一起被使用。</li></ul><p><strong>rows</strong></p><ul><li>​    这个数表示mysql要遍历多少数据才能找到，在innodb上是不准确的。</li></ul><p><strong>Extra</strong></p><ul><li>​    如果是Only index，这意味着信息只用索引树中的信息检索出的，这比扫描整个表要快。</li></ul><ul><li>​    如果是where used，就是使用上了where限制。</li></ul><ul><li>​    如果是impossible where 表示用不着where，一般就是没查出来啥。</li></ul><p>参考链接：<a href="https://blog.csdn.net/u014518337/article/details/88179607" target="_blank" rel="noopener">https://blog.csdn.net/u014518337/article/details/88179607</a></p><p>​                     <a href="https://www.jb51.net/article/158141.htm" target="_blank" rel="noopener">https://www.jb51.net/article/158141.htm</a> </p><p>​                    <a href="https://blog.csdn.net/qq_33451004/article/details/68976090" target="_blank" rel="noopener">https://blog.csdn.net/qq_33451004/article/details/68976090</a></p><p>​                     <a href="https://www.cnblogs.com/luohero/p/9139985.html" target="_blank" rel="noopener">https://www.cnblogs.com/luohero/p/9139985.html</a> </p><p>​                     <a href="https://www.cnblogs.com/l199616j/p/11232392.html" target="_blank" rel="noopener">https://www.cnblogs.com/l199616j/p/11232392.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python脚本向Mysql插入一亿条测试数据</title>
      <link href="/2018/08/08/python%E8%84%9A%E6%9C%AC%E5%90%91Mysql%E6%8F%92%E5%85%A5%E4%B8%80%E4%BA%BF%E6%9D%A1%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/08/08/python%E8%84%9A%E6%9C%AC%E5%90%91Mysql%E6%8F%92%E5%85%A5%E4%B8%80%E4%BA%BF%E6%9D%A1%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>loop_count 为批量插的次数</strong></p><p><strong>batch_size为每次批量查的数据量</strong></p><p><strong>两者通过自定义，实现想插多少插多少。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"><span class="keyword">import</span> MySQLdb.cursors</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量插的次数</span></span><br><span class="line">loop_count = <span class="number">100000</span></span><br><span class="line"><span class="comment"># 每次批量查的数据量</span></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">success_count = <span class="number">0</span></span><br><span class="line">fails_count = <span class="number">0</span></span><br><span class="line"><span class="comment"># 数据库的连接</span></span><br><span class="line"><span class="comment"># 使用 SSCursor (流式游标)，避免客户端占用大量内存。(这个 cursor 实际上没有缓存下来任何数据，它不会读取所有所有到内存中，它的做法是从储存块中读取记录，并且一条一条返回给你。)</span></span><br><span class="line">conn = MySQLdb.connect(host=<span class="string">"47.97.172.176"</span>,</span><br><span class="line">                       user=<span class="string">"root"</span>,</span><br><span class="line">                       passwd=<span class="string">"123456"</span>,</span><br><span class="line">                       db=<span class="string">"test"</span>,</span><br><span class="line">                       port=<span class="number">3306</span>,</span><br><span class="line">                       cursorclass=MySQLdb.cursors.SSCursor)</span><br><span class="line">chars = <span class="string">'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'</span></span><br><span class="line">digits = <span class="string">'0123456789'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_generate_string</span><span class="params">(length)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(chars, length))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_generate_number</span><span class="params">(length)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length &gt; len(digits):</span><br><span class="line">        digit_list = random.sample(digits, len(digits))</span><br><span class="line">        digit_list.append(random.choice(digits))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(digit_list)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(digits, length))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_generate_data</span><span class="params">(num)</span>:</span></span><br><span class="line">    c = [num]</span><br><span class="line">    phone_num_seed = <span class="number">13100000000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_random_generate_data</span><span class="params">()</span>:</span></span><br><span class="line">        c[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (c[<span class="number">0</span>], <span class="string">"last_name_"</span> + str(random.randrange(<span class="number">100000</span>)),</span><br><span class="line">                <span class="string">"first_name_"</span> + str(random.randrange(<span class="number">100000</span>)),</span><br><span class="line">                random.choice(<span class="string">'MF'</span>), random.randint(<span class="number">1</span>, <span class="number">120</span>),</span><br><span class="line">                phone_num_seed + c[<span class="number">0</span>], random_generate_string(<span class="number">20</span>),</span><br><span class="line">                random_generate_string(<span class="number">10</span>), time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _random_generate_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute_many</span><span class="params">(insert_sql, batch_data)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> success_count, fails_count</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.executemany(insert_sql, batch_data)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        conn.rollback()</span><br><span class="line">        fails_count = fails_count + len(batch_data)</span><br><span class="line">        print(e)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        conn.commit()</span><br><span class="line">        success_count = success_count + len(batch_data)</span><br><span class="line">        print(str(success_count) + <span class="string">" commit"</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        cursor.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># user表列的数量</span></span><br><span class="line">    column_count = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 插入的SQL</span></span><br><span class="line">    insert_sql = <span class="string">"replace into user(id, last_name, first_name, sex, age, phone, address, password, create_time) values ("</span> + <span class="string">","</span>.join(</span><br><span class="line">        [<span class="string">"%s"</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(column_count)]) + <span class="string">")"</span></span><br><span class="line">    batch_count = <span class="number">0</span></span><br><span class="line">    begin_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(loop_count):</span><br><span class="line">        batch_count = x * batch_size</span><br><span class="line">        gen_fun = random_generate_data(batch_count)</span><br><span class="line">        batch_data = [gen_fun() <span class="keyword">for</span> x <span class="keyword">in</span> range(batch_size)]</span><br><span class="line">        execute_many(insert_sql, batch_data)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    total_sec = end_time - begin_time</span><br><span class="line">    qps = success_count / total_sec</span><br><span class="line">    print(<span class="string">"总共生成数据： "</span> + str(success_count))</span><br><span class="line">    print(<span class="string">"总共耗时(s): "</span> + str(total_sec))</span><br><span class="line">    print(<span class="string">"QPS: "</span> + str(qps))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>效果图</strong></p><p><img src="/2018/08/08/python脚本向Mysql插入一亿条测试数据/1577242844(1).png" alt="效果图"></p><h4 id="妈妈再也不用担心我测试数据不足啦！"><a href="#妈妈再也不用担心我测试数据不足啦！" class="headerlink" title="妈妈再也不用担心我测试数据不足啦！"></a>妈妈再也不用担心我测试数据不足啦！</h4><p>原文链接找不到啦，抱歉</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python语法：for...else...</title>
      <link href="/2018/08/08/python%E8%AF%AD%E6%B3%95%EF%BC%9Afor-else/"/>
      <url>/2018/08/08/python%E8%AF%AD%E6%B3%95%EF%BC%9Afor-else/</url>
      
        <content type="html"><![CDATA[<h2 id="了解for-和-else-语法"><a href="#了解for-和-else-语法" class="headerlink" title="了解for 和 else 语法"></a>了解for 和 else 语法</h2><blockquote><p> 只要for循环完毕，else就会跑一遍。循环被break中段，则不会走else</p></blockquote><h4 id="当for循环能够顺利循环完毕，则最后输出else-并且else能够打印最后一次的输出"><a href="#当for循环能够顺利循环完毕，则最后输出else-并且else能够打印最后一次的输出" class="headerlink" title="当for循环能够顺利循环完毕，则最后输出else,并且else能够打印最后一次的输出"></a>当for循环能够顺利循环完毕，则最后输出else,并且else能够打印最后一次的输出</h4><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line"></span><br><span class="line">  print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">  print(i, <span class="string">'我是else'</span>)  <span class="comment"># 可以打印</span></span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/python语法：for-else/1.png" alt="img"></p><h4 id="当for-循环被break时，就不会走到else了"><a href="#当for-循环被break时，就不会走到else了" class="headerlink" title="当for 循环被break时，就不会走到else了"></a>当for 循环被break时，就不会走到else了</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> i &gt; <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">  print(i, <span class="string">'我是else'</span>)<span class="comment"># 打印不出来</span></span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/python语法：for-else/2.png" alt="img"></p><h4 id="continue-不会妨碍else"><a href="#continue-不会妨碍else" class="headerlink" title="continue 不会妨碍else"></a>continue 不会妨碍else</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> i &gt; <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">  print(i, <span class="string">'我是else'</span>)<span class="comment"># 可以打印</span></span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/python语法：for-else/3.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> python语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从复制</title>
      <link href="/2018/08/08/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2018/08/08/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>原文并没有把配置过程写的很详细，此文是我亲手配置总结得来。环境centos7    redis-cli 3.2.12</p><p>前面是理论部分，后边为配置的实际代码。可以跳过理论直接上代码！</p><a id="more"></a><p>原文地址： <a href="http://redisdoc.com/topic/replication.html" target="_blank" rel="noopener">http://redisdoc.com/topic/replication.html</a> </p><p>Redis 支持简单且易用的主从复制（master-slave replication）功能， 该功能可以让从服务器(slave server)成为主服务器(master server)的精确复制品。</p><p>以下是关于 Redis 复制功能的几个重要方面：</p><ul><li><p>Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p></li><li><p>一个主服务器可以有多个从服务器。</p></li><li><p>不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</p></li><li><p>复制功能不会阻塞主服务器： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</p></li><li><p>复制功能也不会阻塞从服务器： 只要在 <code>redis.conf</code> 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。</p><p>不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</p><p>你还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</p></li><li><p>复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 [SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]](<a href="http://redisdoc.com/database/sort.html#sort" target="_blank" rel="noopener">http://redisdoc.com/database/sort.html#sort</a>) 命令可以交给附属节点去运行。</p></li><li><p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p></li></ul><h4 id="关闭主服务器持久化时，复制功能的数据安全"><a href="#关闭主服务器持久化时，复制功能的数据安全" class="headerlink" title="关闭主服务器持久化时，复制功能的数据安全"></a>关闭主服务器持久化时，复制功能的数据安全</h4><p>当配置Redis复制功能时，强烈建议打开主服务器的持久化功能。 否则的话，由于延迟等问题，部署的服务应该要避免自动拉起。</p><p>为了帮助理解主服务器关闭持久化时自动拉起的危险性，参考一下以下会导致主从服务器数据全部丢失的例子：</p><p>\1. 假设节点A为主服务器，并且关闭了持久化。 并且节点B和节点C从节点A复制数据</p><p>\2. 节点A崩溃，然后由自动拉起服务重启了节点A. 由于节点A的持久化被关闭了，所以重启之后没有任何数据</p><p>\3. 节点B和节点C将从节点A复制数据，但是A的数据是空的， 于是就把自身保存的数据副本删除。</p><p>在关闭主服务器上的持久化，并同时开启自动拉起进程的情况下，即便使用Sentinel来实现Redis的高可用性，也是非常危险的。 因为主服务器可能拉起得非常快，以至于Sentinel在配置的心跳时间间隔内没有检测到主服务器已被重启，然后还是会执行上面的数据丢失的流程。</p><p>无论何时，数据安全都是极其重要的，所以应该禁止主服务器关闭持久化的同时自动拉起。</p><h4 id="复制功能的运作原理"><a href="#复制功能的运作原理" class="headerlink" title="复制功能的运作原理"></a>复制功能的运作原理</h4><p>无论是初次连接还是重新连接， 当建立一个从服务器时， 从服务器都将向主服务器发送一个 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> 命令。</p><p>接到 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> 命令的主服务器将开始执行 <a href="http://redisdoc.com/persistence/bgsave.html#bgsave" target="_blank" rel="noopener">BGSAVE</a> ， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。</p><p>当 <a href="http://redisdoc.com/persistence/bgsave.html#bgsave" target="_blank" rel="noopener">BGSAVE</a> 执行完毕后， 主服务器将执行保存操作所得的 <code>.rdb</code> 文件发送给从服务器， 从服务器接收这个 <code>.rdb</code> 文件， 并将文件中的数据载入到内存中。</p><p>之后主服务器会以 Redis 命令协议的格式， 将写命令缓冲区中积累的所有内容都发送给从服务器。</p><p>你可以通过 telnet 命令来亲自验证这个同步过程： 首先连上一个正在处理命令请求的 Redis 服务器， 然后向它发送 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> 命令， 过一阵子， 你将看到 telnet 会话（session）接收到服务器发来的大段数据（<code>.rdb</code> 文件）， 之后还会看到， 所有在服务器执行过的写命令， 都会重新发送到 telnet 会话来。</p><p>即使有多个从服务器同时向主服务器发送 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> ， 主服务器也只需执行一次 <a href="http://redisdoc.com/persistence/bgsave.html#bgsave" target="_blank" rel="noopener">BGSAVE</a> 命令， 就可以处理所有这些从服务器的同步请求。</p><p>从服务器可以在主从服务器之间的连接断开时进行自动重连， 在 Redis 2.8 版本之前， 断线之后重连的从服务器总要执行一次完整重同步（full resynchronization）操作， 但是从 Redis 2.8 版本开始， 从服务器可以根据主服务器的情况来选择执行完整重同步还是部分重同步（partial resynchronization）。</p><h4 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h4><p>从 Redis 2.8 开始， 在网络连接短暂性失效之后， 主从服务器可以尝试继续执行原有的复制进程（process）， 而不一定要执行完整重同步操作。</p><p>这个特性需要主服务器为被发送的复制流创建一个内存缓冲区（in-memory backlog）， 并且主服务器和所有从服务器之间都记录一个复制偏移量（replication offset）和一个主服务器 ID （master run id）， 当出现网络连接断开时， 从服务器会重新连接， 并且向主服务器请求继续执行原来的复制进程：</p><ul><li>如果从服务器记录的主服务器 ID 和当前要连接的主服务器的 ID 相同， 并且从服务器记录的偏移量所指定的数据仍然保存在主服务器的复制流缓冲区里面， 那么主服务器会向从服务器发送断线时缺失的那部分数据， 然后复制工作可以继续执行。</li><li>否则的话， 从服务器就要执行完整重同步操作。</li></ul><p>Redis 2.8 的这个部分重同步特性会用到一个新增的 <a href="http://redisdoc.com/internal/psync.html#psync" target="_blank" rel="noopener">PSYNC master_run_id offset</a> 内部命令， 而 Redis 2.8 以前的旧版本只有 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> 命令， 不过， 只要从服务器是 Redis 2.8 或以上的版本， 它就会根据主服务器的版本来决定到底是使用 <a href="http://redisdoc.com/internal/psync.html#psync" target="_blank" rel="noopener">PSYNC master_run_id offset</a> 还是 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> ：</p><ul><li>如果主服务器是 Redis 2.8 或以上版本，那么从服务器使用 <a href="http://redisdoc.com/internal/psync.html#psync" target="_blank" rel="noopener">PSYNC master_run_id offset</a> 命令来进行同步。</li><li>如果主服务器是 Redis 2.8 之前的版本，那么从服务器使用 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> 命令来进行同步。</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h6 id="只读从服务器"><a href="#只读从服务器" class="headerlink" title="只读从服务器"></a>只读从服务器</h6><p>从 Redis 2.6 开始， 从服务器支持只读模式， 并且该模式为从服务器的默认模式。</p><p>只读模式由 <code>redis.conf</code> 文件中的 <code>slave-read-only</code> 选项控制， 也可以通过 <a href="http://redisdoc.com/configure/config_set.html#config-set" target="_blank" rel="noopener">CONFIG SET parameter value</a> 命令来开启或关闭这个模式。</p><p>只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</p><p>即使从服务器是只读的， <code>DEBUG</code> 和 <code>CONFIG</code> 等管理式命令仍然是可以使用的， 所以我们还是不应该将服务器暴露给互联网或者任何不可信网络。 不过， 使用 <code>redis.conf</code> 中的命令改名选项， 我们可以通过禁止执行某些命令来提升只读从服务器的安全性。</p><p>你可能会感到好奇， 既然从服务器上的写数据会被重同步数据覆盖， 也可能在从服务器重启时丢失， 那么为什么要让一个从服务器变得可写呢？</p><p>原因是， 一些不重要的临时数据， 仍然是可以保存在从服务器上面的。 比如说， 客户端可以在从服务器上保存主服务器的可达性（reachability）信息， 从而实现故障转移（failover）策略。</p><h6 id="主服务器只在有至少-N-个从服务器的情况下，才执行写操作"><a href="#主服务器只在有至少-N-个从服务器的情况下，才执行写操作" class="headerlink" title="主服务器只在有至少 N 个从服务器的情况下，才执行写操作"></a>主服务器只在有至少 N 个从服务器的情况下，才执行写操作</h6><p>从 Redis 2.8 开始， 为了保证数据的安全性， 可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下， 才执行写命令。</p><p>不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此， 数据丢失的可能性仍然是存在的。</p><p>以下是这个特性的运作原理：</p><ul><li>从服务器以每秒一次的频率 PING 主服务器一次， 并报告复制流的处理情况。</li><li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li><li>用户可以通过配置， 指定网络延迟的最大值 <code>min-slaves-max-lag</code> ， 以及执行写操作所需的至少从服务器数量 <code>min-slaves-to-write</code> 。</li></ul><p>如果至少有 <code>min-slaves-to-write</code> 个从服务器， 并且这些服务器的延迟值都少于 <code>min-slaves-max-lag</code>秒， 那么主服务器就会执行客户端请求的写操作。</p><p>你可以将这个特性看作 CAP 理论中的 C 的条件放宽版本： 尽管不能保证写操作的持久性， 但起码丢失数据的窗口会被严格限制在指定的秒数中。</p><p>另一方面， 如果条件达不到 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。</p><p>以下是这个特性的两个选项和它们所需的参数：</p><ul><li><code>min-slaves-to-write</code></li><li><code>min-slaves-max-lag</code></li></ul><p>详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p><hr><h4 id="废话少说直接上配置的代码步骤"><a href="#废话少说直接上配置的代码步骤" class="headerlink" title="废话少说直接上配置的代码步骤"></a>废话少说直接上配置的代码步骤</h4><p>以下的配置几乎都在redis.conf中进行，个别在客户端输入</p><p>主机配置</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">to</span>-<span class="built_in">write</span> <span class="number">1</span>    <span class="comment"># 1的话就表示将有一个从机连接主服务器，看自己情况而定</span></span><br><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">max</span>-lag <span class="number">10</span><span class="comment"># 默认或自己定都可</span></span><br><span class="line">requirepass <span class="number">123456</span>       <span class="comment">#从机连接主机的密码，可设可不设，出于安全考虑</span></span><br><span class="line">bind <span class="number">116.64</span><span class="number">.212</span><span class="number">.111</span>      </span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">protected-mode no      <span class="comment"># 关闭保护罩，允许其他服务器连接</span></span><br><span class="line">systemctl restart redis  <span class="comment">#客户端输入，重启加载配置</span></span><br></pre></td></tr></table></figure><p>从机配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">slaveof</span> <span class="number">192.168.1.1</span> <span class="number">6379</span>    <span class="comment">#添加属于某台主机的从 服务</span></span><br><span class="line">masterauth <span class="number">123456</span>       <span class="comment">#从服务连接主服的密码（访问主服务器的密码）</span></span><br><span class="line">slave-read-only <span class="literal">yes</span>     <span class="comment">#从服务只读，不可在命令行写入数据</span></span><br><span class="line">systemctl restart redis  <span class="comment">#客户端输入，重启加载配置</span></span><br></pre></td></tr></table></figure><p>当然， 你需要将代码中的 <code>192.168.1.1</code> 和 <code>6379</code> 替换成你的主服务器的 IP 和端口号。</p><p>另外一种方法是调用 <a href="http://redisdoc.com/replication/slaveof.html#slaveof" target="_blank" rel="noopener">SLAVEOF host port</a> 命令， 输入主服务器的 IP 和端口， 然后同步就会开始：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">SLAVEOF</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> 10086</span><br><span class="line"><span class="selector-tag">OK</span></span><br></pre></td></tr></table></figure><h5 id="从服务器相关配置关于密码说明"><a href="#从服务器相关配置关于密码说明" class="headerlink" title="从服务器相关配置关于密码说明"></a>从服务器相关配置关于密码说明</h5><p>如果主服务器通过 <code>requirepass</code> 选项设置了密码， 那么为了让从服务器的同步操作可以顺利进行， 我们也必须为从服务器进行相应的身份验证设置。同时每次进入主机的redis的客户端时，都要首先输入auth 123456 ，当客户端返回ok后，才可以进行其他操作。</p><p>对于一个正在运行的服务器， 可以使用客户端输入以下命令：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="keyword">set</span> masterauth <span class="comment">&lt;password&gt;</span></span><br></pre></td></tr></table></figure><p>要永久地设置这个密码， 那么可以将它加入到配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth <span class="tag">&lt;<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外还有几个选项， 它们和主服务器执行部分重同步时所使用的复制流缓冲区有关， 详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p><p><strong>最后从机客户端输入info replication 后显示的内容查看是否连接成功：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave      # 表示此台服务器是主是从</span><br><span class="line">master_host:39.107.38.62     # 主服务器ip</span><br><span class="line">master_port:6379        # 主服务器端口号</span><br><span class="line">master_link_status:up       # 与主服务器是否连接成功 up为成功 down失败</span><br><span class="line">master_last_io_seconds_ago:9</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:808</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:ea5230cc485f9c6f372b2c89a65613fb075aff8b</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:808</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:794</span><br></pre></td></tr></table></figure><h5 id="验证是否主服务器写入数据从服务器同步数据"><a href="#验证是否主服务器写入数据从服务器同步数据" class="headerlink" title="验证是否主服务器写入数据从服务器同步数据"></a><strong>验证是否主服务器写入数据从服务器同步数据</strong></h5><p>主机存入key为name，value为zhangsan </p><p><img src="/2018/08/08/redis主从复制/%E4%B8%BB%E6%9C%BA.png" alt="主机"></p><p>从机检查是否同步此条数据</p><p><img src="/2018/08/08/redis主从复制/%E4%BB%8E%E6%9C%BA.png" alt="从机"></p><h5 id="没问题，打完收功！"><a href="#没问题，打完收功！" class="headerlink" title="没问题，打完收功！"></a>没问题，打完收功！</h5><h4 id="可能遇到的报错："><a href="#可能遇到的报错：" class="headerlink" title="可能遇到的报错："></a>可能遇到的报错：</h4><h5 id="1-Error-condition-on-socket-for-SYNC-Connection-refused"><a href="#1-Error-condition-on-socket-for-SYNC-Connection-refused" class="headerlink" title="1. Error condition on socket for SYNC: Connection refused"></a>1. Error condition on socket for SYNC: Connection refused</h5><p>  <strong>出现原因</strong>：</p><p>  ​    redis主服务器绑定了127.0.0.1，跨服务器IP的访问就会失败，只能本机才能访问，外部请求会被过滤。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip: bind 39.107.38.62</span><br><span class="line">3. bind 0.0.0.0</span><br><span class="line">2. 注释bind  # 会报下面的错↓</span><br></pre></td></tr></table></figure><h5 id="2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec"><a href="#2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec" class="headerlink" title="2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec"></a>2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec</h5><p>   <strong>出现原因</strong>：</p><p>   ​    处于保护模式，只能本地链接。没有绑定ip 没有设置验证密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip： bind 39.107.38.62</span><br><span class="line">2. 设置主服务器访问密码：requirepass 12345</span><br></pre></td></tr></table></figure><h5 id="3-error-READONLY-You-can’t-write-against-a-read-only-replica"><a href="#3-error-READONLY-You-can’t-write-against-a-read-only-replica" class="headerlink" title="3. (error) READONLY You can’t write against a read only replica."></a>3. (error) READONLY You can’t write against a read only replica.</h5><p>​    <strong>出现原因</strong>：</p><p>​        从库只可读不可写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 设置slave-read-only no # 代表不限于只读</span><br></pre></td></tr></table></figure><h4 id="断开主从复制"><a href="#断开主从复制" class="headerlink" title="断开主从复制"></a>断开主从复制</h4><p>​    通过<strong>slaveof <masterip> <masterport></masterport></masterip></strong>命令建立主从复制关系以后，可以通过slaveof no one断开。</p><p>从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="/2018/08/08/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2018/08/08/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="首先在centos7下安装redis"><a href="#首先在centos7下安装redis" class="headerlink" title="首先在centos7下安装redis"></a>首先在centos7下安装redis</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yum install redis</span><br><span class="line"></span><br><span class="line">启动服务</span><br><span class="line">systemctl start redis</span><br><span class="line"></span><br><span class="line">查看版本号</span><br><span class="line">redis-cli --version</span><br><span class="line"></span><br><span class="line">设置开机启动</span><br><span class="line">systemctl <span class="built_in">enable</span> redis.service</span><br><span class="line"></span><br><span class="line">进入redis客户端</span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure><a id="more"></a><p>本文将通过下面内容的介绍，希望能够让大家更全面、清晰的认识这两种持久化方式，同时理解这种保存数据的思路，应用于自己的系统设计中。</p><ul><li>持久化的配置</li><li>RDB与AOF持久化的工作原理</li><li>如何从持久化中恢复数据</li><li>关于性能与实践建议</li></ul><h4 id="什么叫持久化？"><a href="#什么叫持久化？" class="headerlink" title="什么叫持久化？"></a>什么叫持久化？</h4><p>用一句话可以将持久化概括为：将数据（如内存中的对象）保存到可永久保存的存储设备中。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、 XML 数据文件中等等。</p><blockquote><p>从应用层与系统层理解持久化</p></blockquote><p>同时，也可以从应用层和系统层这两个层面来理解持久化：</p><p><strong>应用层</strong>：如果关闭( <code>Close</code> )你的应用然后重新启动则先前的数据依然存在。</p><p><strong>系统层</strong>：如果关闭( <code>Shutdown</code> )你的系统（电脑）然后重新启动则先前的数据依然存在。</p><p>说白了，就是在指定的时间间隔内,将内存当中的数据快照写入磁盘,它恢复时是拷快照文件直接读到内存</p><p>什么意思呢?  我们都知道, 内存当中的数据, 如果我们一断电,那么数据必然会丢失,但是玩过redis的同学应该都知道,我们一关机之后再启动的时候数据是还在的,所以它必然是在redis启动的时候重新去加载了持久化的文件</p><h4 id="redis持久化的意义，在于故障恢复"><a href="#redis持久化的意义，在于故障恢复" class="headerlink" title="redis持久化的意义，在于故障恢复"></a>redis持久化的意义，在于故障恢复</h4><p>比如你部署了一个redis，作为cache缓存，当然也可以保存一些较为重要的数据</p><p>如果没有持久化的话，redis遇到灾难性故障的时候，就会丢失所有的数据</p><p>如果通过持久化将数据搞一份儿在磁盘上去，然后定期比如说同步和备份到一些云存储服务上去，那么就可以保证数据不丢失全部，还是可以恢复一部分数据回来的</p><h4 id="Redis为持久化提供了两种方式："><a href="#Redis为持久化提供了两种方式：" class="headerlink" title="Redis为持久化提供了两种方式："></a>Redis为持久化提供了两种方式：</h4><ul><li>RDB：在指定的时间间隔能对你的数据进行快照存储。</li><li>AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。</li></ul><h5 id="RDB是什么？"><a href="#RDB是什么？" class="headerlink" title="RDB是什么？"></a>RDB是什么？</h5><p>原理是redis会单独创建(fork函数)（复制）一个与当前进程一模一样的子进程来进行持久化,这个子线程的所有数据(变量,环境变量,程序,程序计数器等)都和原进程一模一样,会先将数据写入到一个临时文件中,待持久化结束了,再用这个临时文件替换上次持久化好的文件,整个过程中,主进程不进行任何的IO操作,（用到了fork子进程来进行持久化）这就确保了极高的性能</p><h6 id="这个持久化文件在哪里"><a href="#这个持久化文件在哪里" class="headerlink" title="这个持久化文件在哪里"></a>这个持久化文件在哪里</h6><blockquote><p>如果是使用我上述的安装方式安装redis的话，当使用客户端随便存储一条数据，然后就会自动创建这个文件，find出来。</p></blockquote><p><img src="/2018/08/08/redis持久化/1.png" alt="img"></p><h4 id="持久化的配置"><a href="#持久化的配置" class="headerlink" title="持久化的配置"></a>持久化的配置</h4><p>为了使用持久化的功能，我们需要先知道该如何开启持久化的功能。</p><h4 id="RDB的持久化配置"><a href="#RDB的持久化配置" class="headerlink" title="RDB的持久化配置"></a>RDB的持久化配置</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间策略</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件保存路径</span></span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果持久化出错，主进程是否停止写入</span></span><br><span class="line">stop-writes-<span class="literal">on</span>-bgsave-<span class="literal">error</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否压缩</span></span><br><span class="line">rdbcompression <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入时是否检查</span></span><br><span class="line">rdbchecksum <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>配置其实非常简单，这里说一下持久化的时间策略具体是什么意思。</p><ul><li><code>save 900 1</code> 表示900s内如果有1条是写入命令，就触发产生一次快照，可以理解为就进行一次备份</li><li><code>save 300 10</code> 表示300s内有10条写入，就产生快照</li></ul><p>下面的类似，那么为什么需要配置这么多条规则呢？因为Redis每个时段的读写请求肯定不是均衡的，为了平衡性能与数据安全，我们可以自由定制什么情况下触发备份。所以这里就是根据自身Redis写入情况来进行合理配置。</p><p><code>stop-writes-on-bgsave-error yes</code> 这个配置也是非常重要的一项配置，这是当备份进程出错时，主进程就停止接受新的写入操作，是为了保护持久化的数据一致性问题。<strong>如果自己的业务有完善的监控系统，可以禁止此项配置，</strong> 否则请开启。</p><p>关于压缩的配置 <code>rdbcompression yes</code> ，建议没有必要开启，毕竟Redis本身就属于CPU密集型服务器，再开启压缩会带来更多的CPU消耗，相比硬盘成本，CPU更值钱。</p><p>当然如果你想要禁用RDB配置，也是非常容易的，只需要在save的最后一行写上：<code>save &quot;&quot;</code></p><h4 id="AOF的配置"><a href="#AOF的配置" class="headerlink" title="AOF的配置"></a>AOF的配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启aof</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步方式</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof重写期间是否同步</span></span><br><span class="line"><span class="literal">no</span><span class="bullet">-appendfsync-on-rewrite</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写触发配置</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="number">64</span><span class="string">mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载aof时如果有错如何处理</span></span><br><span class="line"><span class="string">aof-load-truncated</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件重写策略</span></span><br><span class="line"><span class="string">aof-rewrite-incremental-fsync</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>还是重点解释一些关键的配置：</p><p><code>appendfsync everysec</code> 它其实有三种模式:</p><ul><li>always：把每个写命令都立即同步到aof，很慢，但是很安全</li><li>everysec：每秒同步一次，是折中方案</li><li>no：redis不处理交给OS来处理，非常快，但是也最不安全</li></ul><p>一般情况下都采用 <strong>everysec</strong> 配置，这样可以兼顾速度与安全，最多损失1s的数据。</p><p><code>aof-load-truncated yes</code> 如果该配置启用，在加载时发现aof尾部不正确是，会向客户端写入一个log，但是会继续执行，如果设置为 <code>no</code> ，发现错误就会停止，必须修复后才能重新加载。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>关于原理部分，我们主要来看RDB与AOF是如何完成持久化的，他们的过程是如何。</p><p>在介绍原理之前先说下Redis内部的定时任务机制，定时任务执行的频率可以在配置文件中通过 <code>hz 10</code> 来设置（这个配置表示1s内执行10次，也就是每100ms触发一次定时任务）。该值最大能够设置为：<strong>500</strong>，但是不建议超过：<strong>100</strong>，因为值越大说明执行频率越频繁越高，这会带来CPU的更多消耗，从而影响主进程读写性能。</p><p>定时任务使用的是Redis自己实现的 <strong>TimeEvent</strong>，它会定时去调用一些命令完成定时任务，这些任务可能会阻塞主进程导致Redis性能下降。因此我们在配置Redis时，一定要整体考虑一些会触发定时任务的配置，根据实际情况进行调整。</p><h4 id="RDB的原理"><a href="#RDB的原理" class="headerlink" title="RDB的原理"></a>RDB的原理</h4><p>在Redis中RDB持久化的触发分为两种：自己手动触发与Redis定时触发。</p><p><strong>针对RDB方式的持久化，手动触发可以使用：</strong></p><ul><li>save：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。</li><li>bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。</li></ul><p><strong>而自动触发的场景主要是有以下几点：</strong></p><ul><li>根据我们的 <code>save m n</code> 配置规则自动触发；</li><li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 <code>bgsave</code>；</li><li>执行 <code>debug reload</code> 时；</li><li>执行 <code>shutdown</code>时，如果没有开启aof，也会触发。</li></ul><p>由于 <code>save</code> 基本不会被使用到，我们重点看看 <code>bgsave</code> 这个命令是如何完成RDB的持久化的。<br><img src="/2018/08/08/redis持久化/C:%5CUsers%5Clenovo%5Cblog%5Csource_posts%5Credis%E6%8C%81%E4%B9%85%E5%8C%96%5C2.png" alt="image1"></p><p>这里注意的是 <code>fork</code> 操作会阻塞，导致Redis读写性能下降。我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。</p><h4 id="AOF的原理"><a href="#AOF的原理" class="headerlink" title="AOF的原理"></a>AOF的原理</h4><p>AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是 <code>appendfsync everysec</code> 配置，会有1s损耗），第二步是对aof文件的重写。</p><p>对于增量追加到文件这一步主要的流程是：命令写入=》追加到aof_buf =》同步到aof磁盘。那么这里为什么要先写入buf在同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。</p><p>aof重写是为了减少aof文件的大小，可以手动或者自动触发，关于自动触发的规则请看上面配置部分。fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。</p><p><strong>手动触发：</strong> <code>bgrewriteaof</code>，<strong>自动触发</strong> 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</p><p>下面来看看重写的一个流程图：<br><img src="/2018/08/08/redis持久化/C:%5CUsers%5Clenovo%5Cblog%5Csource_posts%5Credis%E6%8C%81%E4%B9%85%E5%8C%96%5C3.png" alt="image2"></p><p>对于上图有四个关键点补充一下：</p><ol><li>在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。</li><li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。</li><li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li><li>AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。</li></ol><blockquote><p>不能是RDB还是AOF都是先写入一个临时文件，然后通过 <code>rename</code> 完成文件的替换工作。</p></blockquote><h4 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h4><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p><p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：<br><img src="/2018/08/08/redis持久化/C:%5CUsers%5Clenovo%5Cblog%5Csource_posts%5Credis%E6%8C%81%E4%B9%85%E5%8C%96%5C4.png" alt="image2"></p><p>启动时会先检查AOF文件是否存在，如果不存在就尝试加载RDB。那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p><h4 id="性能与实践"><a href="#性能与实践" class="headerlink" title="性能与实践"></a>性能与实践</h4><p>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</p><ol><li>降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；</li><li>控制Redis最大使用内存，防止fork耗时过长；</li><li>使用更牛逼的硬件；</li><li>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</li></ol><p>在线上我们到底该怎么做？我提供一些自己的实践经验。</p><ol><li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</li><li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</li><li>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</li><li>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</li><li>RDB持久化与AOF持久化可以同时存在，配合使用。</li></ol><p>原文链接： <a href="https://segmentfault.com/a/1190000015983518" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015983518</a> </p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-DBrouter</title>
      <link href="/2018/08/08/Django-DBrouter/"/>
      <url>/2018/08/08/Django-DBrouter/</url>
      
        <content type="html"><![CDATA[<h3 id="DB-router"><a href="#DB-router" class="headerlink" title="DB-router"></a>DB-router</h3><blockquote><p>通过编写<strong>db-router</strong>可以灵性连接<strong>mysql</strong>主从复制等情况下的多数据库</p></blockquote><ul><li>假设你已经配置好了类似<strong>MYSQL</strong>主从复制的服务，如果没有可以参照<a href="https://lienze.tech/blog/mysql/c813917a.html" target="_blank" rel="noopener">这里</a></li></ul><a id="more"></a><h4 id="打开日志用以分析，在-etc-my-conf下加入"><a href="#打开日志用以分析，在-etc-my-conf下加入" class="headerlink" title="打开日志用以分析，在 /etc/my.conf下加入"></a>打开日志用以分析，在 /etc/my.conf下加入</h4><ul><li>可以通过配置<strong>mysql</strong>日志记录，用以查看主从在读写情况下的效果,主从都要配置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#表示永远开启general_log</span></span><br><span class="line">general_log=<span class="number">1</span></span><br><span class="line"><span class="comment">#表示general_log产生的日志文件都写在/var/lib/mysql/general.log里。</span></span><br><span class="line">general_log_file=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure><ul><li>查看是否开启和设置成功</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like '%log%';</span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/Django-DBrouter/1.png" alt="img"></p><ul><li>settings.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'116.62.222.123'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'master'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'ccc'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'slave'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'47.97.172.176'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'ccc'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DATABASE_ROUTERS = [<span class="string">'test1.utils.MasterSlaveDBRouter'</span>]</span><br></pre></td></tr></table></figure><ul><li>编写<strong>db-router</strong>,在主应用下（与settings.py同级）创建utils.py(自定义)，写入下面代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDBRouter</span>:</span></span><br><span class="line">    <span class="string">"""数据库主从读写分离路由"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self, model, **hints)</span>:</span></span><br><span class="line">        <span class="string">"""读数据库"""</span></span><br><span class="line">        <span class="comment"># print 用于测试</span></span><br><span class="line">        print(<span class="string">"给从"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"slave"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_write</span><span class="params">(self, model, **hints)</span>:</span></span><br><span class="line">        <span class="string">"""写数据库"""</span></span><br><span class="line">        print(<span class="string">"给主"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_relation</span><span class="params">(self, obj1, obj2, **hints)</span>:</span></span><br><span class="line">        <span class="string">"""是否运行关联操作"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>如出现以下错误，修改主库binlog日志格式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">django.db.utils.InternalError: (<span class="number">1665</span>, <span class="string">'Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当迁移项目数据时出现上面的错误，在 /etc/my.conf下加入</span></span><br><span class="line">binlog_format=mixed</span><br></pre></td></tr></table></figure><ul><li><p>基本上ok后，可以通过查看general.log，来查看读写情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>进入 日志所在目录，通过下面代码查看后50行数据</span><br><span class="line">cat general.log | tail -n 50</span><br></pre></td></tr></table></figure></li></ul><p>原文链接： <a href="https://lienze.tech/blog/django/7b56b6f5.html" target="_blank" rel="noopener">https://lienze.tech/blog/django/7b56b6f5.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从复制</title>
      <link href="/2018/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2018/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h2><ul><li>什么是<strong>主从复制</strong>？</li></ul><blockquote><p>主从复制至少需要两台服务器，或两个<strong>mysql</strong>服务，可以配置一主多从，多主多从</p><p>建立与某个业务数据库一样的数据库环境，即为主从复制</p><p>一般情况下，主库用以写，而从库用以读</p></blockquote><a id="more"></a><ul><li>为什么要搭建主从复制？<ol><li>构建主从热备，当某天数据库宕机或或数据丢失情况，可以有备份数据库继续工作</li><li>降低IO频次，多库之间可以合理分配读写压力，提高单个数据库服务的数据库访问压力</li><li>隔离读写，在某些锁表情况下，可以使数据库读操作继续进行</li></ol></li></ul><blockquote><p>利用数据库<strong>bin-log</strong>二进制文件，该文件包含有数据库操作的所有SQL语句</p><p>复制该文件至其余数据库服务中并执行即可</p></blockquote><ul><li><p>主从复制过程</p><ol><li><p>当主库具有新数据时，主库会被从库请求，建立线程进行连接，用以传输<strong>binlog</strong>日志</p></li><li><p>从库开启两个线程</p><blockquote><p>A线程：也叫做<strong>IO线程</strong>，连接主库，并请求binlog中的更新记录至从库中，写入至从库的<strong>relaylog</strong>文件中</p><p>B线程：也叫做<strong>SQL线程</strong>，读取<strong>relaylog</strong>文件中的更新操作并执行</p></blockquote></li><li><p>如果，有多个从库同时存在，主库会为每个从库建立一个<strong>binlog</strong>输出线程</p></li></ol></li></ul><p>[<img src="/2018/08/08/主从复制/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E8%87%AA%E7%BB%98.png" alt="主从复制原理自绘">]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="keyword">LOW</span>;<span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote><p>此处以一主一丛为例</p></blockquote><ul><li>系统环境<ul><li>主库（master）：192.168.1.100</li><li>从库（slave）：192.168.1.101</li></ul></li></ul><h3 id="主库修改"><a href="#主库修改" class="headerlink" title="主库修改"></a>主库修改</h3><ul><li>主库配置修改，在 /etc/my.cnf加入下边的代码</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server-id</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">log-bin</span>=mysql-bin <span class="comment"># 开启log </span></span><br><span class="line"><span class="attr">binexpire_logs_days</span>=<span class="number">7</span> <span class="comment"># 日志保存时间</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>server-id</strong>：</p><p>同步数据中必须包含<strong>server-id</strong>，用于标识该语句最初是从哪个<strong>server</strong>写入</p><p>每个<strong>slave</strong>端只能有一个线程在<strong>master</strong>端连接，如果两个<strong>salve</strong>端的<strong>server-id</strong>一致，一个连接成功之后，前一个连接将会被断开</p><p>主主同步时，避免数据同步陷入死循环</p></blockquote><ul><li>主库创建用户，用以从机连接获取<strong>binlog</strong>日志</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'master'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;<span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="keyword">master</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">"123456"</span>;</span><br></pre></td></tr></table></figure><ul><li>查看master状态</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure><ul><li>记录上条命令返回的<strong>binlog</strong>文件名，<strong>Position</strong>属性，从机连接的时候要用</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+<span class="params">------------------</span>+<span class="params">----------</span>+<span class="params">--------------</span>+<span class="params">------------------</span>+<span class="params">-------------------</span>+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+<span class="params">------------------</span>+<span class="params">----------</span>+<span class="params">--------------</span>+<span class="params">------------------</span>+<span class="params">-------------------</span>+| mysql-bin.000001 |      154 |              |                  |                   |+<span class="params">------------------</span>+<span class="params">----------</span>+<span class="params">--------------</span>+<span class="params">------------------</span>+<span class="params">-------------------</span>+1 row in <span class="keyword">set</span> <span class="params">(0.00 sec)</span></span><br></pre></td></tr></table></figure><h3 id="从库修改"><a href="#从库修改" class="headerlink" title="从库修改"></a>从库修改</h3><ul><li>从库配置修改</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server-id</span>=<span class="number">11</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>master</strong>与<strong>slave</strong>端的<strong>server-id</strong>不能一样</p><p><strong>salve</strong>端无需开启<strong>log-bin</strong>功能</p></blockquote><ul><li>从库指定master，执行如下</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> <span class="attribute">master_host</span>=<span class="string">'192.168.1.100'</span>, <span class="attribute">master_port</span>=3306, <span class="attribute">master_user</span>=<span class="string">'master'</span>, <span class="attribute">master_password</span>=<span class="string">'123456'</span>, <span class="attribute">master_log_file</span>=<span class="string">'mysql-bin.000001'</span>, <span class="attribute">master_log_pos</span>=154;</span><br></pre></td></tr></table></figure><ul><li>启动从机</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure><h3 id="同步特定的库"><a href="#同步特定的库" class="headerlink" title="同步特定的库"></a>同步特定的库</h3><h4 id="主机处配置"><a href="#主机处配置" class="headerlink" title="主机处配置"></a>主机处配置</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">binlog-do-db</span>=xxxx   # 二进制日志记录的数据库<span class="attribute">binlog-ignore-db</span>=xxxx # 二进制日志中忽略数据库</span><br></pre></td></tr></table></figure><h4 id="从机处配置"><a href="#从机处配置" class="headerlink" title="从机处配置"></a>从机处配置</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicate-<span class="keyword">do</span>-<span class="keyword">db</span>    # 设定需要复制的数据库replicate-ignore-<span class="keyword">db</span> # 设定需要忽略的复制数据库replicate-<span class="keyword">do</span>-<span class="keyword">table</span>  # 设定需要复制的表replicate-ignore-<span class="keyword">table</span> # 设定需要忽略的复制表replicate-wild-<span class="keyword">do</span>-<span class="keyword">table</span> # 同replication-<span class="keyword">do</span>-<span class="keyword">table</span>功能一样，但是可以通配符replicate-wild-ignore-<span class="keyword">table</span> # 同replication-ignore-<span class="keyword">table</span>功能一样，但是可以加通配符</span><br></pre></td></tr></table></figure><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ul><li><strong>mysql</strong>-&gt;<strong>mariadb</strong>版本问题,当主从使用的分别是<strong>mysql</strong>和<strong>mariadb</strong>时，可能的错误。</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last_IO_Error: Got fatal <span class="keyword">error</span> <span class="number">1236</span> <span class="keyword">from</span> master when reading data <span class="keyword">from</span> binary <span class="built_in">log</span>: 'Client requested master <span class="keyword">to</span> start replication <span class="keyword">from</span> position &gt; <span class="built_in">file</span> size'</span><br></pre></td></tr></table></figure><blockquote><p>从<strong>MySQL5.6</strong>开始引入了<strong>binlog_checksum</strong>全局变量，即<strong>MySQL</strong>会将<strong>event</strong>的<strong>CRC32</strong>校验值也写入<strong>binlog</strong>，显然<strong>MariaDB</strong>在分析日志的时候不会考虑该信息，导致解析出错</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%binlog%'</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> binlog_checksum=<span class="keyword">NONE</span>;</span><br></pre></td></tr></table></figure><ul><li><p>当使用命令show slave status\G;  查看从机与主机的连接状态时，本应该这样：</p><p>​    Slave_IO_Running: Yes</p><p>​    Slave_SQL_Running: Yes    </p><p>​     但是出现了这种情况：</p><p><img src="/2018/08/08/主从复制/%E9%94%99%E8%AF%AF.png" alt="image"></p></li><li><p>处理办法：</p><ul><li>重置mysql数据库 ：systemctl restart mariadb.service</li><li>由此我想到了一个远古的传说：当改变应用程序的配置文件后，先重新启动以保证配置文件生效！！！谨记</li></ul></li></ul><p>原文链接： <a href="https://lienze.tech/blog/mysql/c813917a.html" target="_blank" rel="noopener">https://lienze.tech/blog/mysql/c813917a.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
