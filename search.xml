<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>*args和**kwargs</title>
      <link href="/2018/08/08/args%E5%92%8C-kwargs/"/>
      <url>/2018/08/08/args%E5%92%8C-kwargs/</url>
      
        <content type="html"><![CDATA[<h4 id="args-kwargs-不定长参数"><a href="#args-kwargs-不定长参数" class="headerlink" title="args  *kwargs  不定长参数"></a><em>args  *</em>kwargs  不定长参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jia</span><span class="params">(*args)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(jia(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))         <span class="comment">#6</span></span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>python函数允许同时全部或部分使用使用固定参数，默认参数，单值（一颗星）可变参数，键值对（两颗星）可变参数，使用时必须安装前述顺序书写。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(name, age=<span class="number">18</span>, *args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'姓名:%s,年龄:%d'</span> % (name, age))</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">info(<span class="string">'xuefeng'</span>, <span class="number">23</span>, <span class="number">180</span>, <span class="number">80</span>, like=<span class="string">'python'</span>, body=<span class="string">'fat'</span>)</span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/args和-kwargs/1.png" alt="img"></p><blockquote><p>此外一颗星（单值可变参数）和两颗星（键值对可变参数）还可用于列表，元组，字典的解包。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(*a)               <span class="comment"># 1 2 3</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(*b)               <span class="comment"># 1 2 3</span></span><br><span class="line">c = &#123;<span class="string">'name'</span>: <span class="string">'小明'</span>, <span class="string">'age'</span>: <span class="number">23</span>&#125;</span><br><span class="line">print(*c)               <span class="comment"># name age</span></span><br><span class="line">print(<span class="string">'name:&#123;name&#125;,age:&#123;age&#125;'</span>.format(**c))  <span class="comment"># name:小明,age:23</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>find</title>
      <link href="/2018/08/08/find/"/>
      <url>/2018/08/08/find/</url>
      
        <content type="html"><![CDATA[<h3 id="find命令格式："><a href="#find命令格式：" class="headerlink" title="find命令格式："></a>find命令格式：</h3><p>find   path  -option  【 -print 】  【 -exec   -ok   |xargs  |grep  】 【  command  {} ;  】</p><a id="more"></a><hr><p>find命令的参数：</p><ol><li><p>path：要查找的目录路径。 </p><blockquote><p>  ~ 表示$HOME目录<br>  . 表示当前目录<br>  / 表示根目录 </p></blockquote></li><li><p>print：表示将结果输出到标准输出。</p></li><li><p>exec：对匹配的文件执行该参数所给出的shell命令。 </p><pre><code>形式为command {} \;，注意{}与\;之间有空格 </code></pre></li><li><p>ok：与exec作用相同，</p><pre><code>区别在于，在执行命令之前，都会给出提示，让用户确认是否执行 </code></pre></li><li><p>|xargs  与exec作用相同 ，起承接作用</p><p>区别在于 |xargs 主要用于承接删除操作 ，而 -exec 都可用 如复制、移动、重命名等</p></li><li><p>options ：表示查找方式</p><blockquote><p>options常用的有下选项：</p><p>-name   filename               #查找名为filename的文件<br>-perm                                #按执行权限来查找<br>-user    username             #按文件属主来查找<br>-group groupname            #按组来查找<br>-mtime   -n +n                   #按文件更改时间来查找文件，-n指n天以内，+n指n天以前<br>-atime    -n +n                   #按文件访问时间来查找文件，-n指n天以内，+n指n天以前<br>-ctime    -n +n                  #按文件创建时间来查找文件，-n指n天以内，+n指n天以前<br>-nogroup                          #查无有效属组的文件，即文件的属组在/etc/groups中不存在<br>-nouser                            #查无有效属主的文件，即文件的属主在/etc/passwd中不存<br>-type    b/d/c/p/l/f             #查是块设备、目录、字符设备、管道、符号链接、普通文件<br>-size      n[c]                    #查长度为n块[或n字节]的文件<br>-mount                            #查文件时不跨越文件系统mount点<br>-follow                            #如果遇到符号链接文件，就跟踪链接所指的文件<br>-prune                            #忽略某个目录</p></blockquote></li></ol><hr><p>下面通过一些简单的例子来介绍下find的常规用法： </p><h4 id="1、按名字查找"><a href="#1、按名字查找" class="headerlink" title="1、按名字查找"></a>1、按名字查找</h4><pre><code>在当前目录及子目录中，查找大写字母开头的txt文件  $ find . -name &apos;[A-Z]*.txt&apos; -print 　　在/etc及其子目录中，查找host开头的文件 $ find /etc -name &apos;host*&apos; -print 　　在$HOME目录及其子目录中，查找所有文件 　　$ find ~ -name &apos;*&apos; -print 在当前目录及子目录中，查找不是out开头的txt文件 　　$ find . -name &quot;out*&quot; -prune -o -name &quot;*.txt&quot; -print </code></pre><h4 id="2、按目录查找"><a href="#2、按目录查找" class="headerlink" title="2、按目录查找 　　"></a>2、按目录查找 　　</h4><pre><code>在当前目录除aa之外的子目录内搜索 txt文件 　　$ find . -path &quot;./aa&quot; -prune -o -name &quot;*.txt&quot; -print 　　在当前目录及除aa和bb之外的子目录中查找txt文件 　　$ find . −path′./dir0′−o−path′./dir1′−path′./dir0′−o−path′./dir1′ -a -prune -o -name &apos;*.txt&apos; -print</code></pre><p>注意：在1、2处都需要加空格，否则会出现如图所示的报错</p><pre><code>      在3处加不加 -a都可以 在当前目录，不再子目录中，查找txt文件  $ find . ! -name &quot;.&quot; -type d -prune -o -type f -name &quot;*.txt&quot; -print 或者   find . -name *.txt -type f -print</code></pre><p>友情链接：Linux中find命令-path -prune用法详解</p><h4 id="3、按权限查找"><a href="#3、按权限查找" class="headerlink" title="3、按权限查找 　　"></a>3、按权限查找 　　</h4><p>​      </p><pre><code>在当前目录及子目录中，查找属主具有读写执行，其他具有读执行权限的文件 　　$ find . -perm 755 -print 查找用户有写权限或者组用户有写权限的文件或目录find ./ -perm /220find ./ -perm /u+w,g+wfind ./ -perm /u=w,g=w</code></pre><h4 id="4、按类型查找-（b-d-c-p-l-f-）"><a href="#4、按类型查找-（b-d-c-p-l-f-）" class="headerlink" title="4、按类型查找 　（b/d/c/p/l/f ）　"></a>4、按类型查找 　（b/d/c/p/l/f ）　</h4><pre><code>在当前目录及子目录下，查找符号链接文件 　　$ find . -type l -print </code></pre><h4 id="5、按属主及属组"><a href="#5、按属主及属组" class="headerlink" title="5、按属主及属组 　　"></a>5、按属主及属组 　　</h4><pre><code>查找属主是www的文件 　　$ find / -user www -type f -print 　　查找属主被删除的文件 $ find / -nouser -type f -print 　　查找属组 mysql 的文件 $ find / -group mysql -type f -print 　　查找用户组被删掉的文件 $ find / -nogroup -type f -print </code></pre><h4 id="6、按时间查找"><a href="#6、按时间查找" class="headerlink" title="6、按时间查找 　　"></a>6、按时间查找 　　</h4><pre><code>查找2天内被更改过的文件  $ find . -mtime -2 -type f -print 　　查找2天前被更改过的文件 $ find . -mtime +2 -type f -print 　　查找一天内被访问的文件 $ find . -atime -1 -type f -print 　　查找一天前被访问的文件 $ find . -atime +1 -type f -print 　　查找一天内状态被改变的文件 $ find . -ctime -1 -type f -print 　　查找一天前状态被改变的文件 $ find . -ctime +1 -type f -print 　　查找10分钟以前状态被改变的文件 $ find . -cmin +10 -type f -print </code></pre><h4 id="7、按文件新旧"><a href="#7、按文件新旧" class="headerlink" title="7、按文件新旧 　　"></a>7、按文件新旧 　　</h4><p>​      </p><pre><code>查找比 aa.txt 新的文件 $ find . -newer &quot;aa.txt&quot; -type f -print 　　查找比 aa.txt 旧的文件 $ find . ! -newer &quot;aa.txt&quot; -type f -print 　　查找比aa.txt新，比bb.txt旧的文件 $ find . -newer &apos;aa.txt&apos; ! -newer &apos;bb.txt&apos; -type f -print </code></pre><h4 id="8、按大小查找"><a href="#8、按大小查找" class="headerlink" title="8、按大小查找 　　"></a>8、按大小查找 　　</h4><pre><code>查找超过1M的文件 $ find / -size +1M -type f -print 　　查找等于6字节的文件 $ find . -size 6c -print 　　查找小于32k的文件 $ find . -size -32k -print </code></pre><h4 id="9、执行命令"><a href="#9、执行命令" class="headerlink" title="9、执行命令 　　"></a>9、执行命令 　　</h4><p>​      </p><pre><code>  1）查找 del.txt 并删除，删除前提示确认   $ find . -name &apos;del.txt&apos; -ok rm {} \; 　　 2） 查找 aa.txt 并备份为aa.txt.bak   $ find . -name &apos;aa.txt&apos; -exec cp {} {}.bak \; 3）查当前目录下的所有普通文件# find . -type f -exec ls -l {} \; </code></pre><p>   -rw-r–r–    1 root      root         34928 2003-02-25   ./conf/httpd.conf<br>   -rw-r–r–    1 root      root         12959 2003-02-25   ./conf/magic<br>   -rw-r–r–    1 root      root          180 2003-02-25   ./conf.d/README </p><p>   查当前目录下的所有普通文件，并在 - exec 选项中使用 ls -l 命令将它们列出</p><p>   4）在 /logs 目录中查找更改时间在5日以前的文件并删除它们<br>   $ find logs -type f -mtime +5 -exec   -ok   rm {} ;</p><p>   5）查询当天修改过的文件</p><p>   $ find  ./  -mtime  -1  -type f  -exec  ls -l  {} ; </p><p>   6）查询文件并询问是否要显示</p><pre><code># find   ./   -mtime   -1   -type f   -ok   ls -l   {} \;  &lt; ls … ./classDB.inc.php &gt; ? y-rw-r–r–    1 cnscn    cnscn       13709   1月 12 12:22 ./classDB.inc.php# find   ./   -mtime   -1   -type f   -ok   ls -l   {} \;  &lt; ls … ./classDB.inc.php &gt; ? n</code></pre><p>关于 有没有 -print 的区别</p><h5 id="加-print"><a href="#加-print" class="headerlink" title="加  -print"></a>加  -print</h5><p>查找目录并列出目录下的文件(为找到的每一个目录单独执行ls命令，没有选项-print时文件列表前一行不会显示目录名称)<br>find . -type d -print -exec ls {} ;</p><p><img src="/2018/08/08/find/1.png" alt="img"></p><h5 id="不加-print"><a href="#不加-print" class="headerlink" title="不加 -print"></a>不加 -print</h5><p><img src="/2018/08/08/find/2.png" alt="img"></p><hr><p>原文链接：<a href="https://blog.csdn.net/l_liangkk/article/details/81294260" target="_blank" rel="noopener">https://blog.csdn.net/l_liangkk/article/details/81294260</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep</title>
      <link href="/2018/08/08/grep/"/>
      <url>/2018/08/08/grep/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：grep这个命令都不陌生，最常用的就是和管道符结合，例如：ps-ef-grep-docker。"><a href="#前言：grep这个命令都不陌生，最常用的就是和管道符结合，例如：ps-ef-grep-docker。" class="headerlink" title="前言：grep这个命令都不陌生，最常用的就是和管道符结合，例如：ps -ef | grep docker。"></a>前言：grep这个命令都不陌生，最常用的就是和管道符结合，例如：ps -ef | grep docker。</h2><p>Grep称为全局正则表达式检索工具，在企业中被广泛的采用。</p><a id="more"></a><h2 id="grep的语法格式："><a href="#grep的语法格式：" class="headerlink" title="grep的语法格式："></a>grep的语法格式：</h2><p>grep  -option（参数） ‘word’（关键词） file（文本文件）；</p><h2 id="grep参数："><a href="#grep参数：" class="headerlink" title="grep参数："></a>grep参数：</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-a 不要忽略二进制数据。</span></span><br><span class="line"><span class="deletion">-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</span></span><br><span class="line"><span class="deletion">-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。</span></span><br><span class="line"><span class="deletion">-c 计算符合范本样式的列数。</span></span><br><span class="line"><span class="deletion">-C&lt;显示列数&gt;或-&lt;显示列数&gt;  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span></span><br><span class="line"><span class="deletion">-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。</span></span><br><span class="line"><span class="deletion">-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。</span></span><br><span class="line"><span class="deletion">-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</span></span><br><span class="line"><span class="deletion">-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。</span></span><br><span class="line"><span class="deletion">-F 将范本样式视为固定字符串的列表。</span></span><br><span class="line"><span class="deletion">-G 将范本样式视为普通的表示法来使用。</span></span><br><span class="line"><span class="deletion">-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span></span><br><span class="line"><span class="deletion">-H 在显示符合范本样式的那一列之前，标示该列的文件名称。</span></span><br><span class="line"><span class="deletion">-i 忽略字符大小写的差别。</span></span><br><span class="line"><span class="deletion">-l 列出文件内容符合指定的范本样式的文件名称。</span></span><br><span class="line"><span class="deletion">-L 列出文件内容不符合指定的范本样式的文件名称。</span></span><br><span class="line"><span class="deletion">-n 在显示符合范本样式的那一列之前，标示出该列的编号。</span></span><br><span class="line"><span class="deletion">-q 不显示任何信息。</span></span><br><span class="line"><span class="deletion">-R/-r 此参数的效果和指定“-d recurse”参数相同。</span></span><br><span class="line"><span class="deletion">-s 不显示错误信息。</span></span><br><span class="line"><span class="deletion">-v 反转查找。</span></span><br><span class="line"><span class="deletion">-w 只显示全字符合的列。</span></span><br><span class="line"><span class="deletion">-x 只显示全列符合的列。</span></span><br><span class="line"><span class="deletion">-y 此参数效果跟“-i”相同。</span></span><br><span class="line"><span class="deletion">-o 只输出文件中匹配到的部分。</span></span><br></pre></td></tr></table></figure><h2 id="grep常见用法："><a href="#grep常见用法：" class="headerlink" title="grep常见用法："></a>grep常见用法：</h2><h3 id="1-查找-etc-passwd文件中是否存在quail用户信息"><a href="#1-查找-etc-passwd文件中是否存在quail用户信息" class="headerlink" title="1.查找/etc/passwd文件中是否存在quail用户信息"></a>1.查找/etc/passwd文件中是否存在quail用户信息</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@www</span> sed]<span class="comment"># grep "quail" /etc/passwd</span></span><br><span class="line"><span class="symbol">quail:</span><span class="symbol">x:</span><span class="number">1000</span><span class="symbol">:</span><span class="number">1000</span><span class="symbol">:quail</span><span class="symbol">:/home/quail</span><span class="symbol">:/bin/bash</span></span><br><span class="line">[root<span class="variable">@www</span> sed]<span class="comment"># grep -w "quail" /etc/passwd</span></span><br><span class="line"><span class="symbol">quail:</span><span class="symbol">x:</span><span class="number">1000</span><span class="symbol">:</span><span class="number">1000</span><span class="symbol">:quail</span><span class="symbol">:/home/quail</span><span class="symbol">:/bin/bash</span></span><br><span class="line">[root<span class="variable">@www</span> sed]<span class="comment"># grep -i quail /etc/passwd</span></span><br><span class="line"><span class="symbol">quail:</span><span class="symbol">x:</span><span class="number">1000</span><span class="symbol">:</span><span class="number">1000</span><span class="symbol">:quail</span><span class="symbol">:/home/quail</span><span class="symbol">:/bin/bash</span></span><br></pre></td></tr></table></figure><h3 id="2-ifconfig看到网卡信息，只查看IP地址所在行信息"><a href="#2-ifconfig看到网卡信息，只查看IP地址所在行信息" class="headerlink" title="2.ifconfig看到网卡信息，只查看IP地址所在行信息"></a>2.ifconfig看到网卡信息，只查看IP地址所在行信息</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# ifconfig |grep -w inet</span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.249</span><span class="number">.132</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.249</span><span class="number">.255</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">[root@www sed]# ifconfig |grep netmask</span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.249</span><span class="number">.132</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.249</span><span class="number">.255</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">[root@www sed]# ifconfig |grep -w <span class="number">255</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.249</span><span class="number">.132</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.249</span><span class="number">.255</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">[root@www sed]# ifconfig |grep -E <span class="string">"192|127"</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.249</span><span class="number">.132</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.249</span><span class="number">.255</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">[root@www sed]# ifconfig |grep -E <span class="string">"([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;"</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.249</span><span class="number">.132</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.249</span><span class="number">.255</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h4 id="实验需要，新建list-txt并写入如下内容："><a href="#实验需要，新建list-txt并写入如下内容：" class="headerlink" title="实验需要，新建list.txt并写入如下内容："></a>实验需要，新建list.txt并写入如下内容：</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# cat <span class="type">list</span>.txt </span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.4</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.5</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span> www <span class="number">123456</span></span><br><span class="line"><span class="number">1111.222</span><span class="number">.111</span><span class="number">.111</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">111.22</span><span class="number">.11</span><span class="number">.1111</span> root <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="3-统计root-字符总行数"><a href="#3-统计root-字符总行数" class="headerlink" title="3.统计root 字符总行数"></a>3.统计root 字符总行数</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@www</span> sed]<span class="meta"># grep -c root list.txt </span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="4-不区分大小写查找RoOt所有行"><a href="#4-不区分大小写查找RoOt所有行" class="headerlink" title="4.不区分大小写查找RoOt所有行"></a>4.不区分大小写查找RoOt所有行</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep -i RoOt <span class="type">list</span>.txt </span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.4</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.5</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">1111.222</span><span class="number">.111</span><span class="number">.111</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">111.22</span><span class="number">.11</span><span class="number">.1111</span> root <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="5-打印www行以及行号"><a href="#5-打印www行以及行号" class="headerlink" title="5.打印www行以及行号"></a>5.打印www行以及行号</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@www sed]</span># <span class="selector-tag">grep</span> <span class="selector-tag">-n</span> <span class="selector-tag">www</span> <span class="selector-tag">list</span><span class="selector-class">.txt</span> </span><br><span class="line">6<span class="selector-pseudo">:172.0.0.1</span> <span class="selector-tag">www</span> 123456</span><br></pre></td></tr></table></figure><h3 id="6-不打印root行"><a href="#6-不打印root行" class="headerlink" title="6.不打印root行"></a>6.不打印root行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@www sed]</span># <span class="selector-tag">grep</span> <span class="selector-tag">-v</span> <span class="selector-tag">root</span> <span class="selector-tag">list</span><span class="selector-class">.txt</span> </span><br><span class="line">172<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">www</span> 123456</span><br></pre></td></tr></table></figure><h3 id="7-以168-开头的接3-5的行"><a href="#7-以168-开头的接3-5的行" class="headerlink" title="7.以168.开头的接3 5的行"></a>7.以168.开头的接3 5的行</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep <span class="string">"168.[35]"</span> <span class="type">list</span>.txt </span><br><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.5</span><span class="number">.11</span> root <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="8-显示输出行首不是192的行"><a href="#8-显示输出行首不是192的行" class="headerlink" title="8.显示输出行首不是192的行"></a>8.显示输出行首不是192的行</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep -E -v  <span class="string">"^192"</span> <span class="type">list</span>.txt </span><br><span class="line"><span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span> www <span class="number">123456</span></span><br><span class="line"><span class="number">1111.222</span><span class="number">.111</span><span class="number">.111</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">111.22</span><span class="number">.11</span><span class="number">.1111</span> root <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="9-匹配R或r开头的行-提前echo-“root-123-nRoot-123”-gt-list-txt"><a href="#9-匹配R或r开头的行-提前echo-“root-123-nRoot-123”-gt-list-txt" class="headerlink" title="9.匹配R或r开头的行,提前echo “root 123\nRoot 123” &gt; list.txt"></a>9.匹配R或r开头的行,提前echo “root 123\nRoot 123” &gt; list.txt</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep -E <span class="string">"^[Rr]oot"</span> <span class="type">list</span>.txt </span><br><span class="line">root <span class="number">1234</span> <span class="number">2134</span> <span class="number">123</span></span><br><span class="line">Root <span class="number">123</span> <span class="number">123</span> <span class="number">123</span> <span class="number">786</span></span><br></pre></td></tr></table></figure><h3 id="10-匹配r，两个任意字符，紧接t的行"><a href="#10-匹配r，两个任意字符，紧接t的行" class="headerlink" title="10.匹配r，两个任意字符，紧接t的行"></a>10.匹配r，两个任意字符，紧接t的行</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep <span class="string">"r..t"</span> <span class="type">list</span>.txt </span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.4</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.5</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">1111.222</span><span class="number">.111</span><span class="number">.111</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">111.22</span><span class="number">.11</span><span class="number">.1111</span> root <span class="number">123456</span></span><br><span class="line">root <span class="number">1234</span> <span class="number">2134</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="11-匹配字母紧跟w-的行"><a href="#11-匹配字母紧跟w-的行" class="headerlink" title="11.匹配字母紧跟w 的行"></a>11.匹配字母紧跟w 的行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@www sed]</span># <span class="selector-tag">grep</span> <span class="selector-tag">-E</span> "<span class="selector-attr">[a-Z]</span><span class="selector-tag">w</span> " <span class="selector-tag">list</span><span class="selector-class">.txt</span> </span><br><span class="line">172<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">www</span> 123456</span><br></pre></td></tr></table></figure><h3 id="12-打印字符w字符连续出现2次以上的行"><a href="#12-打印字符w字符连续出现2次以上的行" class="headerlink" title="12.打印字符w字符连续出现2次以上的行"></a>12.打印字符w字符连续出现2次以上的行</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep <span class="string">"w\&#123;2,\&#125;"</span> <span class="type">list</span>.txt </span><br><span class="line"><span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span> www <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="13-打印字符o连续出现3次和5次的行"><a href="#13-打印字符o连续出现3次和5次的行" class="headerlink" title="13.打印字符o连续出现3次和5次的行"></a>13.打印字符o连续出现3次和5次的行</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@www</span> sed]<span class="meta"># grep <span class="string">"o\&#123;3,5\&#125;"</span> list.txt </span></span><br><span class="line">rooot</span><br><span class="line">rooooot</span><br></pre></td></tr></table></figure><h3 id="14-打印-usr-local-nginx-conf-nginx-conf-default空行的所在的行号"><a href="#14-打印-usr-local-nginx-conf-nginx-conf-default空行的所在的行号" class="headerlink" title="14.打印/usr/local/nginx/conf/nginx.conf.default空行的所在的行号"></a>14.打印/usr/local/nginx/conf/nginx.conf.default空行的所在的行号</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]<span class="comment"># grep -n "^$" /usr/local/nginx/conf/nginx.conf.default </span></span><br><span class="line"><span class="section">1:</span></span><br><span class="line"><span class="section">4:</span></span><br><span class="line"><span class="section">8:</span></span><br><span class="line"><span class="section">10:</span></span><br><span class="line"><span class="section">11:</span></span><br><span class="line"><span class="section">15:</span></span><br><span class="line"><span class="section">16:</span></span><br><span class="line"><span class="section">20:</span></span><br><span class="line"><span class="section">24:</span></span><br><span class="line"><span class="section">26:</span></span><br><span class="line"><span class="section">29:</span></span><br><span class="line"><span class="section">32:</span></span><br><span class="line"><span class="section">34:</span></span><br><span class="line"><span class="section">38:</span></span><br><span class="line"><span class="section">40:</span></span><br><span class="line"><span class="section">42:</span></span><br><span class="line"><span class="section">47:</span></span><br><span class="line"><span class="section">49:</span></span><br><span class="line"><span class="section">56:</span></span><br><span class="line"><span class="section">62:</span></span><br><span class="line"><span class="section">72:</span></span><br><span class="line"><span class="section">80:</span></span><br><span class="line"><span class="section">81:</span></span><br><span class="line"><span class="section">88:</span></span><br><span class="line"><span class="section">94:</span></span><br><span class="line"><span class="section">95:</span></span><br><span class="line"><span class="section">101:</span></span><br><span class="line"><span class="section">104:</span></span><br><span class="line"><span class="section">107:</span></span><br><span class="line"><span class="section">110:</span></span><br><span class="line"><span class="section">116:</span></span><br></pre></td></tr></table></figure><h3 id="15-过滤-usr-local-nginx-conf-nginx-conf-default文件中的-和空行以及行号"><a href="#15-过滤-usr-local-nginx-conf-nginx-conf-default文件中的-和空行以及行号" class="headerlink" title="15.过滤/usr/local/nginx/conf/nginx.conf.default文件中的#和空行以及行号"></a>15.过滤/usr/local/nginx/conf/nginx.conf.default文件中的#和空行以及行号</h3><p>[root@www sed]# grep -E -v -n “#|^$” /usr/local/nginx/conf/nginx.conf.default<br>3:worker_processes 1;<br>12:events {<br>13: worker_connections 1024;<br>14:}<br>17:http {<br>18: include mime.types;<br>19: default_type application/octet-stream;<br>27: sendfile on;<br>31: keepalive_timeout 65;<br>35: server {<br>36: listen 80;<br>37: server_name localhost;<br>43: location / {<br>44: root html;<br>45: index index.html index.htm;<br>46: }<br>52: error_page 500 502 503 504 /50x.html;<br>53: location = /50x.html {<br>54: root html;<br>55: }<br>79: }<br>117:}</p><h3 id="16-当前目录下文件内匹配包含quail或test或anchun的文件"><a href="#16-当前目录下文件内匹配包含quail或test或anchun的文件" class="headerlink" title="16.当前目录下文件内匹配包含quail或test或anchun的文件"></a>16.当前目录下文件内匹配包含quail或test或anchun的文件</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">`seq 1 3`</span>;<span class="keyword">do</span> echo quail$i &gt; test$i.txt ;done</span><br><span class="line">[root@www sed]# <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">`seq 1 3`</span>;<span class="keyword">do</span> echo test$i &gt; yoyoyo$i.txt ;done</span><br><span class="line">[root@www sed]# <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">`seq 1 3`</span>;<span class="keyword">do</span> echo anchun$i &gt; lalal$i.txt ;done</span><br><span class="line">[root@www sed]# <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">`seq 1 3`</span>;<span class="keyword">do</span> echo <span class="keyword">error</span>$i &gt; yingyingying$i.txt ;done ######实验环境######</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# <span class="keyword">grep</span> -E -ra <span class="string">"quail|test|anchun"</span> *</span><br><span class="line">lalal1.tx<span class="variable">t:anchun1</span></span><br><span class="line">lalal2.tx<span class="variable">t:anchun2</span></span><br><span class="line">lalal3.tx<span class="variable">t:anchun3</span></span><br><span class="line">test1.tx<span class="variable">t:quail1</span></span><br><span class="line">test2.tx<span class="variable">t:quail2</span></span><br><span class="line">test3.tx<span class="variable">t:quail3</span></span><br><span class="line">yoyoyo1.tx<span class="variable">t:test1</span></span><br><span class="line">yoyoyo2.tx<span class="variable">t:test2</span></span><br><span class="line">yoyoyo3.tx<span class="variable">t:test3</span></span><br></pre></td></tr></table></figure><h3 id="17-匹配IPV4地址"><a href="#17-匹配IPV4地址" class="headerlink" title="17.匹配IPV4地址"></a>17.匹配IPV4地址</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www sed]# grep -E -w --color <span class="string">"([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;"</span> <span class="type">list</span>.txt </span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.4</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.5</span><span class="number">.11</span> root <span class="number">123456</span></span><br><span class="line"><span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span> www <span class="number">123456</span></span><br></pre></td></tr></table></figure><hr><p>原文链接： <a href="https://www.cnblogs.com/quail2333/p/11179106.html" target="_blank" rel="noopener">https://www.cnblogs.com/quail2333/p/11179106.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从复制</title>
      <link href="/2018/08/08/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2018/08/08/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>原文并没有把配置过程写的很详细，此文是我亲手配置总结得来。环境centos7    redis-cli 3.2.12</p><p>前面是理论部分，后边为配置的实际代码。可以跳过理论直接上代码！</p><a id="more"></a><p>原文地址： <a href="http://redisdoc.com/topic/replication.html" target="_blank" rel="noopener">http://redisdoc.com/topic/replication.html</a> </p><p>Redis 支持简单且易用的主从复制（master-slave replication）功能， 该功能可以让从服务器(slave server)成为主服务器(master server)的精确复制品。</p><p>以下是关于 Redis 复制功能的几个重要方面：</p><ul><li><p>Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p></li><li><p>一个主服务器可以有多个从服务器。</p></li><li><p>不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</p></li><li><p>复制功能不会阻塞主服务器： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</p></li><li><p>复制功能也不会阻塞从服务器： 只要在 <code>redis.conf</code> 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。</p><p>不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</p><p>你还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</p></li><li><p>复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 [SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]](<a href="http://redisdoc.com/database/sort.html#sort" target="_blank" rel="noopener">http://redisdoc.com/database/sort.html#sort</a>) 命令可以交给附属节点去运行。</p></li><li><p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p></li></ul><h4 id="关闭主服务器持久化时，复制功能的数据安全"><a href="#关闭主服务器持久化时，复制功能的数据安全" class="headerlink" title="关闭主服务器持久化时，复制功能的数据安全"></a>关闭主服务器持久化时，复制功能的数据安全</h4><p>当配置Redis复制功能时，强烈建议打开主服务器的持久化功能。 否则的话，由于延迟等问题，部署的服务应该要避免自动拉起。</p><p>为了帮助理解主服务器关闭持久化时自动拉起的危险性，参考一下以下会导致主从服务器数据全部丢失的例子：</p><p>\1. 假设节点A为主服务器，并且关闭了持久化。 并且节点B和节点C从节点A复制数据</p><p>\2. 节点A崩溃，然后由自动拉起服务重启了节点A. 由于节点A的持久化被关闭了，所以重启之后没有任何数据</p><p>\3. 节点B和节点C将从节点A复制数据，但是A的数据是空的， 于是就把自身保存的数据副本删除。</p><p>在关闭主服务器上的持久化，并同时开启自动拉起进程的情况下，即便使用Sentinel来实现Redis的高可用性，也是非常危险的。 因为主服务器可能拉起得非常快，以至于Sentinel在配置的心跳时间间隔内没有检测到主服务器已被重启，然后还是会执行上面的数据丢失的流程。</p><p>无论何时，数据安全都是极其重要的，所以应该禁止主服务器关闭持久化的同时自动拉起。</p><h4 id="复制功能的运作原理"><a href="#复制功能的运作原理" class="headerlink" title="复制功能的运作原理"></a>复制功能的运作原理</h4><p>无论是初次连接还是重新连接， 当建立一个从服务器时， 从服务器都将向主服务器发送一个 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> 命令。</p><p>接到 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> 命令的主服务器将开始执行 <a href="http://redisdoc.com/persistence/bgsave.html#bgsave" target="_blank" rel="noopener">BGSAVE</a> ， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。</p><p>当 <a href="http://redisdoc.com/persistence/bgsave.html#bgsave" target="_blank" rel="noopener">BGSAVE</a> 执行完毕后， 主服务器将执行保存操作所得的 <code>.rdb</code> 文件发送给从服务器， 从服务器接收这个 <code>.rdb</code> 文件， 并将文件中的数据载入到内存中。</p><p>之后主服务器会以 Redis 命令协议的格式， 将写命令缓冲区中积累的所有内容都发送给从服务器。</p><p>你可以通过 telnet 命令来亲自验证这个同步过程： 首先连上一个正在处理命令请求的 Redis 服务器， 然后向它发送 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> 命令， 过一阵子， 你将看到 telnet 会话（session）接收到服务器发来的大段数据（<code>.rdb</code> 文件）， 之后还会看到， 所有在服务器执行过的写命令， 都会重新发送到 telnet 会话来。</p><p>即使有多个从服务器同时向主服务器发送 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> ， 主服务器也只需执行一次 <a href="http://redisdoc.com/persistence/bgsave.html#bgsave" target="_blank" rel="noopener">BGSAVE</a> 命令， 就可以处理所有这些从服务器的同步请求。</p><p>从服务器可以在主从服务器之间的连接断开时进行自动重连， 在 Redis 2.8 版本之前， 断线之后重连的从服务器总要执行一次完整重同步（full resynchronization）操作， 但是从 Redis 2.8 版本开始， 从服务器可以根据主服务器的情况来选择执行完整重同步还是部分重同步（partial resynchronization）。</p><h4 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h4><p>从 Redis 2.8 开始， 在网络连接短暂性失效之后， 主从服务器可以尝试继续执行原有的复制进程（process）， 而不一定要执行完整重同步操作。</p><p>这个特性需要主服务器为被发送的复制流创建一个内存缓冲区（in-memory backlog）， 并且主服务器和所有从服务器之间都记录一个复制偏移量（replication offset）和一个主服务器 ID （master run id）， 当出现网络连接断开时， 从服务器会重新连接， 并且向主服务器请求继续执行原来的复制进程：</p><ul><li>如果从服务器记录的主服务器 ID 和当前要连接的主服务器的 ID 相同， 并且从服务器记录的偏移量所指定的数据仍然保存在主服务器的复制流缓冲区里面， 那么主服务器会向从服务器发送断线时缺失的那部分数据， 然后复制工作可以继续执行。</li><li>否则的话， 从服务器就要执行完整重同步操作。</li></ul><p>Redis 2.8 的这个部分重同步特性会用到一个新增的 <a href="http://redisdoc.com/internal/psync.html#psync" target="_blank" rel="noopener">PSYNC master_run_id offset</a> 内部命令， 而 Redis 2.8 以前的旧版本只有 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> 命令， 不过， 只要从服务器是 Redis 2.8 或以上的版本， 它就会根据主服务器的版本来决定到底是使用 <a href="http://redisdoc.com/internal/psync.html#psync" target="_blank" rel="noopener">PSYNC master_run_id offset</a> 还是 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> ：</p><ul><li>如果主服务器是 Redis 2.8 或以上版本，那么从服务器使用 <a href="http://redisdoc.com/internal/psync.html#psync" target="_blank" rel="noopener">PSYNC master_run_id offset</a> 命令来进行同步。</li><li>如果主服务器是 Redis 2.8 之前的版本，那么从服务器使用 <a href="http://redisdoc.com/internal/sync.html#sync" target="_blank" rel="noopener">SYNC</a> 命令来进行同步。</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h6 id="只读从服务器"><a href="#只读从服务器" class="headerlink" title="只读从服务器"></a>只读从服务器</h6><p>从 Redis 2.6 开始， 从服务器支持只读模式， 并且该模式为从服务器的默认模式。</p><p>只读模式由 <code>redis.conf</code> 文件中的 <code>slave-read-only</code> 选项控制， 也可以通过 <a href="http://redisdoc.com/configure/config_set.html#config-set" target="_blank" rel="noopener">CONFIG SET parameter value</a> 命令来开启或关闭这个模式。</p><p>只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</p><p>即使从服务器是只读的， <code>DEBUG</code> 和 <code>CONFIG</code> 等管理式命令仍然是可以使用的， 所以我们还是不应该将服务器暴露给互联网或者任何不可信网络。 不过， 使用 <code>redis.conf</code> 中的命令改名选项， 我们可以通过禁止执行某些命令来提升只读从服务器的安全性。</p><p>你可能会感到好奇， 既然从服务器上的写数据会被重同步数据覆盖， 也可能在从服务器重启时丢失， 那么为什么要让一个从服务器变得可写呢？</p><p>原因是， 一些不重要的临时数据， 仍然是可以保存在从服务器上面的。 比如说， 客户端可以在从服务器上保存主服务器的可达性（reachability）信息， 从而实现故障转移（failover）策略。</p><h6 id="主服务器只在有至少-N-个从服务器的情况下，才执行写操作"><a href="#主服务器只在有至少-N-个从服务器的情况下，才执行写操作" class="headerlink" title="主服务器只在有至少 N 个从服务器的情况下，才执行写操作"></a>主服务器只在有至少 N 个从服务器的情况下，才执行写操作</h6><p>从 Redis 2.8 开始， 为了保证数据的安全性， 可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下， 才执行写命令。</p><p>不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此， 数据丢失的可能性仍然是存在的。</p><p>以下是这个特性的运作原理：</p><ul><li>从服务器以每秒一次的频率 PING 主服务器一次， 并报告复制流的处理情况。</li><li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li><li>用户可以通过配置， 指定网络延迟的最大值 <code>min-slaves-max-lag</code> ， 以及执行写操作所需的至少从服务器数量 <code>min-slaves-to-write</code> 。</li></ul><p>如果至少有 <code>min-slaves-to-write</code> 个从服务器， 并且这些服务器的延迟值都少于 <code>min-slaves-max-lag</code>秒， 那么主服务器就会执行客户端请求的写操作。</p><p>你可以将这个特性看作 CAP 理论中的 C 的条件放宽版本： 尽管不能保证写操作的持久性， 但起码丢失数据的窗口会被严格限制在指定的秒数中。</p><p>另一方面， 如果条件达不到 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。</p><p>以下是这个特性的两个选项和它们所需的参数：</p><ul><li><code>min-slaves-to-write</code></li><li><code>min-slaves-max-lag</code></li></ul><p>详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p><hr><h4 id="废话少说直接上配置的代码步骤"><a href="#废话少说直接上配置的代码步骤" class="headerlink" title="废话少说直接上配置的代码步骤"></a>废话少说直接上配置的代码步骤</h4><p>以下的配置几乎都在redis.conf中进行，个别在客户端输入</p><p>主机配置</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">to</span>-<span class="built_in">write</span> <span class="number">1</span>    <span class="comment"># 1的话就表示将有一个从机连接主服务器，看自己情况而定</span></span><br><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">max</span>-lag <span class="number">10</span><span class="comment"># 默认或自己定都可</span></span><br><span class="line">requirepass <span class="number">123456</span>       <span class="comment">#从机连接主机的密码，可设可不设，出于安全考虑</span></span><br><span class="line">bind <span class="number">116.64</span><span class="number">.212</span><span class="number">.111</span>      </span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">protected-mode no      <span class="comment"># 关闭保护罩，允许其他服务器连接</span></span><br><span class="line">systemctl restart redis  <span class="comment">#客户端输入，重启加载配置</span></span><br></pre></td></tr></table></figure><p>从机配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">slaveof</span> <span class="number">192.168.1.1</span> <span class="number">6379</span>    <span class="comment">#添加属于某台主机的从 服务</span></span><br><span class="line">masterauth <span class="number">123456</span>       <span class="comment">#从服务连接主服的密码（访问主服务器的密码）</span></span><br><span class="line">slave-read-only <span class="literal">yes</span>     <span class="comment">#从服务只读，不可在命令行写入数据</span></span><br><span class="line">systemctl restart redis  <span class="comment">#客户端输入，重启加载配置</span></span><br></pre></td></tr></table></figure><p>当然， 你需要将代码中的 <code>192.168.1.1</code> 和 <code>6379</code> 替换成你的主服务器的 IP 和端口号。</p><p>另外一种方法是调用 <a href="http://redisdoc.com/replication/slaveof.html#slaveof" target="_blank" rel="noopener">SLAVEOF host port</a> 命令， 输入主服务器的 IP 和端口， 然后同步就会开始：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">SLAVEOF</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> 10086</span><br><span class="line"><span class="selector-tag">OK</span></span><br></pre></td></tr></table></figure><h5 id="从服务器相关配置关于密码说明"><a href="#从服务器相关配置关于密码说明" class="headerlink" title="从服务器相关配置关于密码说明"></a>从服务器相关配置关于密码说明</h5><p>如果主服务器通过 <code>requirepass</code> 选项设置了密码， 那么为了让从服务器的同步操作可以顺利进行， 我们也必须为从服务器进行相应的身份验证设置。同时每次进入主机的redis的客户端时，都要首先输入auth 123456 ，当客户端返回ok后，才可以进行其他操作。</p><p>对于一个正在运行的服务器， 可以使用客户端输入以下命令：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="keyword">set</span> masterauth <span class="comment">&lt;password&gt;</span></span><br></pre></td></tr></table></figure><p>要永久地设置这个密码， 那么可以将它加入到配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth <span class="tag">&lt;<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外还有几个选项， 它们和主服务器执行部分重同步时所使用的复制流缓冲区有关， 详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p><p><strong>最后从机客户端输入info replication 后显示的内容查看是否连接成功：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave      # 表示此台服务器是主是从</span><br><span class="line">master_host:39.107.38.62     # 主服务器ip</span><br><span class="line">master_port:6379        # 主服务器端口号</span><br><span class="line">master_link_status:up       # 与主服务器是否连接成功 up为成功 down失败</span><br><span class="line">master_last_io_seconds_ago:9</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:808</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:ea5230cc485f9c6f372b2c89a65613fb075aff8b</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:808</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:794</span><br></pre></td></tr></table></figure><h5 id="验证是否主服务器写入数据从服务器同步数据"><a href="#验证是否主服务器写入数据从服务器同步数据" class="headerlink" title="验证是否主服务器写入数据从服务器同步数据"></a><strong>验证是否主服务器写入数据从服务器同步数据</strong></h5><p>主机存入key为name，value为zhangsan </p><p><img src="/2018/08/08/redis主从复制/%E4%B8%BB%E6%9C%BA.png" alt="主机"></p><p>从机检查是否同步此条数据</p><p>![从机](redis主从复制/从机 .png)</p><h5 id="没问题，打完收功！"><a href="#没问题，打完收功！" class="headerlink" title="没问题，打完收功！"></a>没问题，打完收功！</h5><h4 id="可能遇到的报错："><a href="#可能遇到的报错：" class="headerlink" title="可能遇到的报错："></a>可能遇到的报错：</h4><h5 id="1-Error-condition-on-socket-for-SYNC-Connection-refused"><a href="#1-Error-condition-on-socket-for-SYNC-Connection-refused" class="headerlink" title="1. Error condition on socket for SYNC: Connection refused"></a>1. Error condition on socket for SYNC: Connection refused</h5><p>  <strong>出现原因</strong>：</p><p>  ​    redis主服务器绑定了127.0.0.1，跨服务器IP的访问就会失败，只能本机才能访问，外部请求会被过滤。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip: bind 39.107.38.62</span><br><span class="line">3. bind 0.0.0.0</span><br><span class="line">2. 注释bind  # 会报下面的错↓</span><br></pre></td></tr></table></figure><h5 id="2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec"><a href="#2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec" class="headerlink" title="2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec"></a>2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec</h5><p>   <strong>出现原因</strong>：</p><p>   ​    处于保护模式，只能本地链接。没有绑定ip 没有设置验证密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip： bind 39.107.38.62</span><br><span class="line">2. 设置主服务器访问密码：requirepass 12345</span><br></pre></td></tr></table></figure><h5 id="3-error-READONLY-You-can’t-write-against-a-read-only-replica"><a href="#3-error-READONLY-You-can’t-write-against-a-read-only-replica" class="headerlink" title="3. (error) READONLY You can’t write against a read only replica."></a>3. (error) READONLY You can’t write against a read only replica.</h5><p>​    <strong>出现原因</strong>：</p><p>​        从库只可读不可写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 设置slave-read-only no # 代表不限于只读</span><br></pre></td></tr></table></figure><h4 id="断开主从复制"><a href="#断开主从复制" class="headerlink" title="断开主从复制"></a>断开主从复制</h4><p>​    通过<strong>slaveof <masterip> <masterport></masterport></masterip></strong>命令建立主从复制关系以后，可以通过slaveof no one断开。</p><p>从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="/2018/08/08/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2018/08/08/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="首先在centos7下安装redis"><a href="#首先在centos7下安装redis" class="headerlink" title="首先在centos7下安装redis"></a>首先在centos7下安装redis</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yum install redis</span><br><span class="line"></span><br><span class="line">启动服务</span><br><span class="line">systemctl start redis</span><br><span class="line"></span><br><span class="line">查看版本号</span><br><span class="line">redis-cli --version</span><br><span class="line"></span><br><span class="line">设置开机启动</span><br><span class="line">systemctl <span class="built_in">enable</span> redis.service</span><br><span class="line"></span><br><span class="line">进入redis客户端</span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure><a id="more"></a><p>本文将通过下面内容的介绍，希望能够让大家更全面、清晰的认识这两种持久化方式，同时理解这种保存数据的思路，应用于自己的系统设计中。</p><ul><li>持久化的配置</li><li>RDB与AOF持久化的工作原理</li><li>如何从持久化中恢复数据</li><li>关于性能与实践建议</li></ul><h4 id="什么叫持久化？"><a href="#什么叫持久化？" class="headerlink" title="什么叫持久化？"></a>什么叫持久化？</h4><p>用一句话可以将持久化概括为：将数据（如内存中的对象）保存到可永久保存的存储设备中。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、 XML 数据文件中等等。</p><blockquote><p>从应用层与系统层理解持久化</p></blockquote><p>同时，也可以从应用层和系统层这两个层面来理解持久化：</p><p><strong>应用层</strong>：如果关闭( <code>Close</code> )你的应用然后重新启动则先前的数据依然存在。</p><p><strong>系统层</strong>：如果关闭( <code>Shutdown</code> )你的系统（电脑）然后重新启动则先前的数据依然存在。</p><p>说白了，就是在指定的时间间隔内,将内存当中的数据快照写入磁盘,它恢复时是拷快照文件直接读到内存</p><p>什么意思呢?  我们都知道, 内存当中的数据, 如果我们一断电,那么数据必然会丢失,但是玩过redis的同学应该都知道,我们一关机之后再启动的时候数据是还在的,所以它必然是在redis启动的时候重新去加载了持久化的文件</p><h4 id="redis持久化的意义，在于故障恢复"><a href="#redis持久化的意义，在于故障恢复" class="headerlink" title="redis持久化的意义，在于故障恢复"></a>redis持久化的意义，在于故障恢复</h4><p>比如你部署了一个redis，作为cache缓存，当然也可以保存一些较为重要的数据</p><p>如果没有持久化的话，redis遇到灾难性故障的时候，就会丢失所有的数据</p><p>如果通过持久化将数据搞一份儿在磁盘上去，然后定期比如说同步和备份到一些云存储服务上去，那么就可以保证数据不丢失全部，还是可以恢复一部分数据回来的</p><h4 id="Redis为持久化提供了两种方式："><a href="#Redis为持久化提供了两种方式：" class="headerlink" title="Redis为持久化提供了两种方式："></a>Redis为持久化提供了两种方式：</h4><ul><li>RDB：在指定的时间间隔能对你的数据进行快照存储。</li><li>AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。</li></ul><h5 id="RDB是什么？"><a href="#RDB是什么？" class="headerlink" title="RDB是什么？"></a>RDB是什么？</h5><p>原理是redis会单独创建(fork函数)（复制）一个与当前进程一模一样的子进程来进行持久化,这个子线程的所有数据(变量,环境变量,程序,程序计数器等)都和原进程一模一样,会先将数据写入到一个临时文件中,待持久化结束了,再用这个临时文件替换上次持久化好的文件,整个过程中,主进程不进行任何的IO操作,（用到了fork子进程来进行持久化）这就确保了极高的性能</p><h6 id="这个持久化文件在哪里"><a href="#这个持久化文件在哪里" class="headerlink" title="这个持久化文件在哪里"></a>这个持久化文件在哪里</h6><blockquote><p>如果是使用我上述的安装方式安装redis的话，当使用客户端随便存储一条数据，然后就会自动创建这个文件，find出来。</p></blockquote><p><img src="/2018/08/08/redis持久化/1.png" alt="img"></p><h4 id="持久化的配置"><a href="#持久化的配置" class="headerlink" title="持久化的配置"></a>持久化的配置</h4><p>为了使用持久化的功能，我们需要先知道该如何开启持久化的功能。</p><h4 id="RDB的持久化配置"><a href="#RDB的持久化配置" class="headerlink" title="RDB的持久化配置"></a>RDB的持久化配置</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间策略</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件保存路径</span></span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果持久化出错，主进程是否停止写入</span></span><br><span class="line">stop-writes-<span class="literal">on</span>-bgsave-<span class="literal">error</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否压缩</span></span><br><span class="line">rdbcompression <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入时是否检查</span></span><br><span class="line">rdbchecksum <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>配置其实非常简单，这里说一下持久化的时间策略具体是什么意思。</p><ul><li><code>save 900 1</code> 表示900s内如果有1条是写入命令，就触发产生一次快照，可以理解为就进行一次备份</li><li><code>save 300 10</code> 表示300s内有10条写入，就产生快照</li></ul><p>下面的类似，那么为什么需要配置这么多条规则呢？因为Redis每个时段的读写请求肯定不是均衡的，为了平衡性能与数据安全，我们可以自由定制什么情况下触发备份。所以这里就是根据自身Redis写入情况来进行合理配置。</p><p><code>stop-writes-on-bgsave-error yes</code> 这个配置也是非常重要的一项配置，这是当备份进程出错时，主进程就停止接受新的写入操作，是为了保护持久化的数据一致性问题。<strong>如果自己的业务有完善的监控系统，可以禁止此项配置，</strong> 否则请开启。</p><p>关于压缩的配置 <code>rdbcompression yes</code> ，建议没有必要开启，毕竟Redis本身就属于CPU密集型服务器，再开启压缩会带来更多的CPU消耗，相比硬盘成本，CPU更值钱。</p><p>当然如果你想要禁用RDB配置，也是非常容易的，只需要在save的最后一行写上：<code>save &quot;&quot;</code></p><h4 id="AOF的配置"><a href="#AOF的配置" class="headerlink" title="AOF的配置"></a>AOF的配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启aof</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步方式</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof重写期间是否同步</span></span><br><span class="line"><span class="literal">no</span><span class="bullet">-appendfsync-on-rewrite</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写触发配置</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="number">64</span><span class="string">mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载aof时如果有错如何处理</span></span><br><span class="line"><span class="string">aof-load-truncated</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件重写策略</span></span><br><span class="line"><span class="string">aof-rewrite-incremental-fsync</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>还是重点解释一些关键的配置：</p><p><code>appendfsync everysec</code> 它其实有三种模式:</p><ul><li>always：把每个写命令都立即同步到aof，很慢，但是很安全</li><li>everysec：每秒同步一次，是折中方案</li><li>no：redis不处理交给OS来处理，非常快，但是也最不安全</li></ul><p>一般情况下都采用 <strong>everysec</strong> 配置，这样可以兼顾速度与安全，最多损失1s的数据。</p><p><code>aof-load-truncated yes</code> 如果该配置启用，在加载时发现aof尾部不正确是，会向客户端写入一个log，但是会继续执行，如果设置为 <code>no</code> ，发现错误就会停止，必须修复后才能重新加载。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>关于原理部分，我们主要来看RDB与AOF是如何完成持久化的，他们的过程是如何。</p><p>在介绍原理之前先说下Redis内部的定时任务机制，定时任务执行的频率可以在配置文件中通过 <code>hz 10</code> 来设置（这个配置表示1s内执行10次，也就是每100ms触发一次定时任务）。该值最大能够设置为：<strong>500</strong>，但是不建议超过：<strong>100</strong>，因为值越大说明执行频率越频繁越高，这会带来CPU的更多消耗，从而影响主进程读写性能。</p><p>定时任务使用的是Redis自己实现的 <strong>TimeEvent</strong>，它会定时去调用一些命令完成定时任务，这些任务可能会阻塞主进程导致Redis性能下降。因此我们在配置Redis时，一定要整体考虑一些会触发定时任务的配置，根据实际情况进行调整。</p><h4 id="RDB的原理"><a href="#RDB的原理" class="headerlink" title="RDB的原理"></a>RDB的原理</h4><p>在Redis中RDB持久化的触发分为两种：自己手动触发与Redis定时触发。</p><p><strong>针对RDB方式的持久化，手动触发可以使用：</strong></p><ul><li>save：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。</li><li>bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。</li></ul><p><strong>而自动触发的场景主要是有以下几点：</strong></p><ul><li>根据我们的 <code>save m n</code> 配置规则自动触发；</li><li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 <code>bgsave</code>；</li><li>执行 <code>debug reload</code> 时；</li><li>执行 <code>shutdown</code>时，如果没有开启aof，也会触发。</li></ul><p>由于 <code>save</code> 基本不会被使用到，我们重点看看 <code>bgsave</code> 这个命令是如何完成RDB的持久化的。<br><img src="/2018/08/08/redis持久化/C:%5CUsers%5Clenovo%5Cblog%5Csource_posts%5Credis%E6%8C%81%E4%B9%85%E5%8C%96%5C2.png" alt="image1"></p><p>这里注意的是 <code>fork</code> 操作会阻塞，导致Redis读写性能下降。我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。</p><h4 id="AOF的原理"><a href="#AOF的原理" class="headerlink" title="AOF的原理"></a>AOF的原理</h4><p>AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是 <code>appendfsync everysec</code> 配置，会有1s损耗），第二步是对aof文件的重写。</p><p>对于增量追加到文件这一步主要的流程是：命令写入=》追加到aof_buf =》同步到aof磁盘。那么这里为什么要先写入buf在同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。</p><p>aof重写是为了减少aof文件的大小，可以手动或者自动触发，关于自动触发的规则请看上面配置部分。fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。</p><p><strong>手动触发：</strong> <code>bgrewriteaof</code>，<strong>自动触发</strong> 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</p><p>下面来看看重写的一个流程图：<br><img src="/2018/08/08/redis持久化/C:%5CUsers%5Clenovo%5Cblog%5Csource_posts%5Credis%E6%8C%81%E4%B9%85%E5%8C%96%5C3.png" alt="image2"></p><p>对于上图有四个关键点补充一下：</p><ol><li>在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。</li><li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。</li><li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li><li>AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。</li></ol><blockquote><p>不能是RDB还是AOF都是先写入一个临时文件，然后通过 <code>rename</code> 完成文件的替换工作。</p></blockquote><h4 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h4><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p><p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：<br><img src="/2018/08/08/redis持久化/C:%5CUsers%5Clenovo%5Cblog%5Csource_posts%5Credis%E6%8C%81%E4%B9%85%E5%8C%96%5C4.png" alt="image2"></p><p>启动时会先检查AOF文件是否存在，如果不存在就尝试加载RDB。那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p><h4 id="性能与实践"><a href="#性能与实践" class="headerlink" title="性能与实践"></a>性能与实践</h4><p>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</p><ol><li>降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；</li><li>控制Redis最大使用内存，防止fork耗时过长；</li><li>使用更牛逼的硬件；</li><li>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</li></ol><p>在线上我们到底该怎么做？我提供一些自己的实践经验。</p><ol><li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</li><li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</li><li>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</li><li>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</li><li>RDB持久化与AOF持久化可以同时存在，配合使用。</li></ol><p>原文链接： <a href="https://segmentfault.com/a/1190000015983518" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015983518</a> </p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python语法：for...else...</title>
      <link href="/2018/08/08/python%E8%AF%AD%E6%B3%95%EF%BC%9Afor-else/"/>
      <url>/2018/08/08/python%E8%AF%AD%E6%B3%95%EF%BC%9Afor-else/</url>
      
        <content type="html"><![CDATA[<h2 id="了解for-和-else-语法"><a href="#了解for-和-else-语法" class="headerlink" title="了解for 和 else 语法"></a>了解for 和 else 语法</h2><blockquote><p> 只要for循环完毕，else就会跑一遍。循环被break中段，则不会走else</p></blockquote><h4 id="当for循环能够顺利循环完毕，则最后输出else-并且else能够打印最后一次的输出"><a href="#当for循环能够顺利循环完毕，则最后输出else-并且else能够打印最后一次的输出" class="headerlink" title="当for循环能够顺利循环完毕，则最后输出else,并且else能够打印最后一次的输出"></a>当for循环能够顺利循环完毕，则最后输出else,并且else能够打印最后一次的输出</h4><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line"></span><br><span class="line">  print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">  print(i, <span class="string">'我是else'</span>)  <span class="comment"># 可以打印</span></span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/python语法：for-else/1.png" alt="img"></p><h4 id="当for-循环被break时，就不会走到else了"><a href="#当for-循环被break时，就不会走到else了" class="headerlink" title="当for 循环被break时，就不会走到else了"></a>当for 循环被break时，就不会走到else了</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> i &gt; <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">  print(i, <span class="string">'我是else'</span>)<span class="comment"># 打印不出来</span></span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/python语法：for-else/2.png" alt="img"></p><h4 id="continue-不会妨碍else"><a href="#continue-不会妨碍else" class="headerlink" title="continue 不会妨碍else"></a>continue 不会妨碍else</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> i &gt; <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">  print(i, <span class="string">'我是else'</span>)<span class="comment"># 可以打印</span></span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/python语法：for-else/3.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> python语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-DBrouter</title>
      <link href="/2018/08/08/Django-DBrouter/"/>
      <url>/2018/08/08/Django-DBrouter/</url>
      
        <content type="html"><![CDATA[<h3 id="DB-router"><a href="#DB-router" class="headerlink" title="DB-router"></a>DB-router</h3><blockquote><p>通过编写<strong>db-router</strong>可以灵性连接<strong>mysql</strong>主从复制等情况下的多数据库</p></blockquote><ul><li>假设你已经配置好了类似<strong>MYSQL</strong>主从复制的服务，如果没有可以参照<a href="https://lienze.tech/blog/mysql/c813917a.html" target="_blank" rel="noopener">这里</a></li></ul><a id="more"></a><h4 id="打开日志用以分析，在-etc-my-conf下加入"><a href="#打开日志用以分析，在-etc-my-conf下加入" class="headerlink" title="打开日志用以分析，在 /etc/my.conf下加入"></a>打开日志用以分析，在 /etc/my.conf下加入</h4><ul><li>可以通过配置<strong>mysql</strong>日志记录，用以查看主从在读写情况下的效果,主从都要配置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#表示永远开启general_log</span></span><br><span class="line">general_log=<span class="number">1</span></span><br><span class="line"><span class="comment">#表示general_log产生的日志文件都写在/var/lib/mysql/general.log里。</span></span><br><span class="line">general_log_file=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure><ul><li>查看是否开启和设置成功</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like '%log%';</span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/Django-DBrouter/1.png" alt="img"></p><ul><li>settings.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'116.62.222.123'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'master'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'ccc'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'slave'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'47.97.172.176'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'ccc'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DATABASE_ROUTERS = [<span class="string">'test1.utils.MasterSlaveDBRouter'</span>]</span><br></pre></td></tr></table></figure><ul><li>编写<strong>db-router</strong>,在主应用下（与settings.py同级）创建utils.py(自定义)，写入下面代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDBRouter</span>:</span></span><br><span class="line">    <span class="string">"""数据库主从读写分离路由"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self, model, **hints)</span>:</span></span><br><span class="line">        <span class="string">"""读数据库"""</span></span><br><span class="line">        <span class="comment"># print 用于测试</span></span><br><span class="line">        print(<span class="string">"给从"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"slave"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_write</span><span class="params">(self, model, **hints)</span>:</span></span><br><span class="line">        <span class="string">"""写数据库"""</span></span><br><span class="line">        print(<span class="string">"给主"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_relation</span><span class="params">(self, obj1, obj2, **hints)</span>:</span></span><br><span class="line">        <span class="string">"""是否运行关联操作"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>如出现以下错误，修改主库binlog日志格式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">django.db.utils.InternalError: (<span class="number">1665</span>, <span class="string">'Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当迁移项目数据时出现上面的错误，在 /etc/my.conf下加入</span></span><br><span class="line">binlog_format=mixed</span><br></pre></td></tr></table></figure><ul><li><p>基本上ok后，可以通过查看general.log，来查看读写情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>进入 日志所在目录，通过下面代码查看后50行数据</span><br><span class="line">cat general.log | tail -n 50</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从复制</title>
      <link href="/2018/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2018/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h2><ul><li>什么是<strong>主从复制</strong>？</li></ul><blockquote><p>主从复制至少需要两台服务器，或两个<strong>mysql</strong>服务，可以配置一主多从，多主多从</p><p>建立与某个业务数据库一样的数据库环境，即为主从复制</p><p>一般情况下，主库用以写，而从库用以读</p></blockquote><a id="more"></a><ul><li>为什么要搭建主从复制？<ol><li>构建主从热备，当某天数据库宕机或或数据丢失情况，可以有备份数据库继续工作</li><li>降低IO频次，多库之间可以合理分配读写压力，提高单个数据库服务的数据库访问压力</li><li>隔离读写，在某些锁表情况下，可以使数据库读操作继续进行</li></ol></li></ul><blockquote><p>利用数据库<strong>bin-log</strong>二进制文件，该文件包含有数据库操作的所有SQL语句</p><p>复制该文件至其余数据库服务中并执行即可</p></blockquote><ul><li><p>主从复制过程</p><ol><li><p>当主库具有新数据时，主库会被从库请求，建立线程进行连接，用以传输<strong>binlog</strong>日志</p></li><li><p>从库开启两个线程</p><blockquote><p>A线程：也叫做<strong>IO线程</strong>，连接主库，并请求binlog中的更新记录至从库中，写入至从库的<strong>relaylog</strong>文件中</p><p>B线程：也叫做<strong>SQL线程</strong>，读取<strong>relaylog</strong>文件中的更新操作并执行</p></blockquote></li><li><p>如果，有多个从库同时存在，主库会为每个从库建立一个<strong>binlog</strong>输出线程</p></li></ol></li></ul><p>[<img src="/2018/08/08/主从复制/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E8%87%AA%E7%BB%98.png" alt="主从复制原理自绘">]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="keyword">LOW</span>;<span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote><p>此处以一主一丛为例</p></blockquote><ul><li>系统环境<ul><li>主库（master）：192.168.1.100</li><li>从库（slave）：192.168.1.101</li></ul></li></ul><h3 id="主库修改"><a href="#主库修改" class="headerlink" title="主库修改"></a>主库修改</h3><ul><li>主库配置修改，在 /etc/my.cnf加入下边的代码</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server-id</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">log-bin</span>=mysql-bin <span class="comment"># 开启log </span></span><br><span class="line"><span class="attr">binexpire_logs_days</span>=<span class="number">7</span> <span class="comment"># 日志保存时间</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>server-id</strong>：</p><p>同步数据中必须包含<strong>server-id</strong>，用于标识该语句最初是从哪个<strong>server</strong>写入</p><p>每个<strong>slave</strong>端只能有一个线程在<strong>master</strong>端连接，如果两个<strong>salve</strong>端的<strong>server-id</strong>一致，一个连接成功之后，前一个连接将会被断开</p><p>主主同步时，避免数据同步陷入死循环</p></blockquote><ul><li>主库创建用户，用以从机连接获取<strong>binlog</strong>日志</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'master'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;<span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="keyword">master</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">"123456"</span>;</span><br></pre></td></tr></table></figure><ul><li>查看master状态</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure><ul><li>记录上条命令返回的<strong>binlog</strong>文件名，<strong>Position</strong>属性，从机连接的时候要用</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+<span class="params">------------------</span>+<span class="params">----------</span>+<span class="params">--------------</span>+<span class="params">------------------</span>+<span class="params">-------------------</span>+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+<span class="params">------------------</span>+<span class="params">----------</span>+<span class="params">--------------</span>+<span class="params">------------------</span>+<span class="params">-------------------</span>+| mysql-bin.000001 |      154 |              |                  |                   |+<span class="params">------------------</span>+<span class="params">----------</span>+<span class="params">--------------</span>+<span class="params">------------------</span>+<span class="params">-------------------</span>+1 row in <span class="keyword">set</span> <span class="params">(0.00 sec)</span></span><br></pre></td></tr></table></figure><h3 id="从库修改"><a href="#从库修改" class="headerlink" title="从库修改"></a>从库修改</h3><ul><li>从库配置修改</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server-id</span>=<span class="number">11</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>master</strong>与<strong>slave</strong>端的<strong>server-id</strong>不能一样</p><p><strong>salve</strong>端无需开启<strong>log-bin</strong>功能</p></blockquote><ul><li>从库指定master，执行如下</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> <span class="attribute">master_host</span>=<span class="string">'192.168.1.100'</span>, <span class="attribute">master_port</span>=3306, <span class="attribute">master_user</span>=<span class="string">'master'</span>, <span class="attribute">master_password</span>=<span class="string">'123456'</span>, <span class="attribute">master_log_file</span>=<span class="string">'mysql-bin.000001'</span>, <span class="attribute">master_log_pos</span>=154;</span><br></pre></td></tr></table></figure><ul><li>启动从机</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure><h3 id="同步特定的库"><a href="#同步特定的库" class="headerlink" title="同步特定的库"></a>同步特定的库</h3><h4 id="主机处配置"><a href="#主机处配置" class="headerlink" title="主机处配置"></a>主机处配置</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">binlog-do-db</span>=xxxx   # 二进制日志记录的数据库<span class="attribute">binlog-ignore-db</span>=xxxx # 二进制日志中忽略数据库</span><br></pre></td></tr></table></figure><h4 id="从机处配置"><a href="#从机处配置" class="headerlink" title="从机处配置"></a>从机处配置</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicate-<span class="keyword">do</span>-<span class="keyword">db</span>    # 设定需要复制的数据库replicate-ignore-<span class="keyword">db</span> # 设定需要忽略的复制数据库replicate-<span class="keyword">do</span>-<span class="keyword">table</span>  # 设定需要复制的表replicate-ignore-<span class="keyword">table</span> # 设定需要忽略的复制表replicate-wild-<span class="keyword">do</span>-<span class="keyword">table</span> # 同replication-<span class="keyword">do</span>-<span class="keyword">table</span>功能一样，但是可以通配符replicate-wild-ignore-<span class="keyword">table</span> # 同replication-ignore-<span class="keyword">table</span>功能一样，但是可以加通配符</span><br></pre></td></tr></table></figure><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ul><li><strong>mysql</strong>-&gt;<strong>mariadb</strong>版本问题,当主从使用的分别是<strong>mysql</strong>和<strong>mariadb</strong>时，可能的错误。</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last_IO_Error: Got fatal <span class="keyword">error</span> <span class="number">1236</span> <span class="keyword">from</span> master when reading data <span class="keyword">from</span> binary <span class="built_in">log</span>: 'Client requested master <span class="keyword">to</span> start replication <span class="keyword">from</span> position &gt; <span class="built_in">file</span> size'</span><br></pre></td></tr></table></figure><blockquote><p>从<strong>MySQL5.6</strong>开始引入了<strong>binlog_checksum</strong>全局变量，即<strong>MySQL</strong>会将<strong>event</strong>的<strong>CRC32</strong>校验值也写入<strong>binlog</strong>，显然<strong>MariaDB</strong>在分析日志的时候不会考虑该信息，导致解析出错</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%binlog%'</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> binlog_checksum=<span class="keyword">NONE</span>;</span><br></pre></td></tr></table></figure><ul><li><p>当使用命令show slave status\G;  查看从机与主机的连接状态时，本应该这样：</p><p>​    Slave_IO_Running: Yes</p><p>​    Slave_SQL_Running: Yes    </p><p>​     但是出现了这种情况：</p><p><img src="/2018/08/08/主从复制/%E9%94%99%E8%AF%AF.png" alt="image"></p></li><li><p>处理办法：</p><ul><li>重置mysql数据库 ：systemctl restart mariadb.service</li><li>由此我想到了一个远古的传说：当改变应用程序的配置文件后，先重新启动以保证配置文件生效！！！谨记</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
